<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>media-sync-api adapter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; line-height: 1.6; color: #0f172a; }
    code { background: #e2e8f0; padding: 0.15rem 0.35rem; border-radius: 4px; }
    pre { background: #0f172a; color: #e2e8f0; padding: 1rem; border-radius: 6px; overflow-x: auto; }
    h1, h2, h3 { color: #0b132b; }
    .callout { background: #f8fafc; border-left: 4px solid #2563eb; padding: 0.75rem 1rem; margin: 1rem 0; }
    .step { margin-bottom: 1.25rem; }
    ul { margin-top: 0.35rem; }
    .panel { border: 1px solid #e2e8f0; border-radius: 6px; padding: 1rem; margin: 0.75rem 0; }
    .hidden { display: none; }
    .pill { display: inline-block; padding: 0.35rem 0.6rem; border-radius: 999px; background: #eef2ff; color: #312e81; margin: 0.2rem 0.25rem; cursor: pointer; border: 1px solid #c7d2fe; }
    .pill:hover { background: #c7d2fe; }
    .media-row { display: flex; justify-content: space-between; align-items: center; padding: 0.25rem 0; border-bottom: 1px solid #e2e8f0; }
    .media-row:last-child { border-bottom: none; }
    .media-actions button { padding: 0.35rem 0.75rem; border: none; background: #2563eb; color: white; border-radius: 4px; cursor: pointer; }
    .media-actions button:hover { background: #1e4fc8; }
    .upload-panel { margin-top: 0.75rem; padding: 0.75rem; border: 1px dashed #cbd5e1; border-radius: 6px; background: #f8fafc; }
    .upload-panel input[type="file"] { margin-bottom: 0.5rem; }
    .upload-panel button { padding: 0.35rem 0.75rem; border: none; background: #047857; color: white; border-radius: 4px; cursor: pointer; }
    .upload-panel button:hover { background: #065f46; }
    .muted { color: #475569; font-size: 0.95rem; }
    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
    .sources-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 0.5rem; }
    .sources-grid div { padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 6px; background: #f8fafc; }
    .source-form label { display: block; margin-bottom: 0.35rem; }
    .source-form input { width: 100%; padding: 0.4rem; margin-top: 0.15rem; box-sizing: border-box; }
    .source-form button { margin-top: 0.35rem; padding: 0.35rem 0.75rem; border: none; background: #1d4ed8; color: white; border-radius: 4px; cursor: pointer; }
    .source-form button:hover { background: #1e40af; }
  </style>
</head>
<body>
  <h1>media-sync-api</h1>
  <p>This lightweight, LAN-only API sits between your phone and host project storage. Mount <code>../Projects</code> on the host to <code>/data/projects</code> in the container, then use the endpoints below or the iPhone Shortcut flow to ingest media reliably.</p>

  <div class="callout">
    <strong>New: Browser-native explorer</strong><br />
    Use the panel below to list projects, browse indexed files, and play media directly from the Projects volume without downloading.
  </div>

  <section id="sources-panel" class="panel">
    <h2>Sources</h2>
    <p>Destinations for projects and uploads. Use this to confirm mounts and register additional roots (e.g., NAS shares).</p>
    <div id="sources" class="sources-grid"></div>
    <div class="source-form" aria-live="polite">
      <h3>Add a source</h3>
      <label for="source-name">Name</label>
      <input id="source-name" name="source-name" placeholder="nas" />
      <label for="source-root">Absolute path on host</label>
      <input id="source-root" name="source-root" placeholder="/mnt/nas/projects" />
      <label for="source-type">Type (optional)</label>
      <input id="source-type" name="source-type" placeholder="local|smb|nfs" />
      <button id="source-add" type="button">Save source</button>
      <div id="source-status" class="muted"></div>
    </div>
  </section>

  <section id="browser-explorer">
    <h2>Browser explorer</h2>
    <p>Click a project to view its indexed media. Files stream via the API with HTTP range support, so large clips play inline.</p>
    <div id="projects" class="panel"></div>
    <div id="media" class="panel hidden">
      <h3 id="media-title">Media</h3>
      <div id="upload" class="upload-panel hidden" aria-live="polite">
        <p class="muted" id="upload-caption">Select a project to upload media.</p>
        <input type="file" id="upload-file" class="visually-hidden" aria-label="Select media to upload" />
        <div>
          <button id="upload-picker" type="button">Choose file</button>
        </div>
        <div>
          <button id="upload-button" type="button">Upload</button>
        </div>
        <div id="upload-status" class="muted"></div>
      </div>
      <div id="media-list"></div>
      <div id="player" class="hidden">
        <h4>Preview</h4>
        <video id="video-player" controls style="max-width: 100%; height: auto;" aria-label="Media preview"></video>
        <p id="media-meta"></p>
      </div>
    </div>
  </section>

  <div class="callout">
    <strong>Host/LAN defaults</strong><br />
    API: <code>http://192.168.0.25:8787</code><br />
    Projects root: Host <code>B:\Video\Projects</code> → Container <code>/data/projects</code>
  </div>

  <h2>Playbook: verify → create projects → ingest → dedupe → reindex</h2>

  <div class="step">
    <h3>1) Verify it is running and writing to your Projects folder</h3>
    <ul>
      <li>Health: <code>http://192.168.0.25:8787/health</code></li>
      <li>List projects: <code>http://192.168.0.25:8787/api/projects</code></li>
    </ul>
    <p>If <code>/api/projects</code> returns an empty list, create one and confirm <code>index.json</code>, <code>ingest/</code>, and <code>_manifest/</code> exist under <code>../Projects/&lt;project&gt;</code> on the host.</p>
  </div>

  <div class="step">
    <h3>2) Create your first project (API)</h3>
    <p>Use curl from the host:</p>
    <pre>curl -X POST http://127.0.0.1:8787/api/projects \
  -H "Content-Type: application/json" \
  -d "{\"name\":\"P1-Public-Accountability\",\"notes\":\"Main production ingest\"}"</pre>
    <p>Then confirm: <code>curl http://127.0.0.1:8787/api/projects</code></p>
  </div>

  <div class="step">
    <h3>3) iPhone Shortcut outline</h3>
    <p>Select project → optional create → prompt for label → pick videos → upload → optional sync log.</p>
    <ol>
      <li>GET <code>/api/projects</code> → build list (append "➕ Create New Project").</li>
      <li>If creating: POST <code>/api/projects</code> with <code>{ "name": NewName, "notes": Notes }</code>.</li>
      <li>Ask for input <em>EntryLabel</em>, choose videos.</li>
      <li>Optional audit: POST <code>/api/projects/{Project}/sync-album</code> with JSON <code>{ "album_name": EntryLabel, "device": "iphone", "note": "Shortcut ingest" }</code>.</li>
      <li>For each file: POST <code>/api/projects/{Project}/upload</code> form field <code>file</code>.</li>
    </ol>
    <p>No duplicate handling is needed client-side—the API hashes and skips repeats automatically.</p>
  </div>

  <div class="step">
    <h3>4) Prove de-dupe is working</h3>
    <p>Upload 2–3 videos, then run the Shortcut again selecting the same files. Expected:</p>
    <ul>
      <li>Second run returns <code>"status": "duplicate"</code>.</li>
      <li><code>index.json</code> increments <code>duplicates_skipped</code>.</li>
      <li>No new media is stored.</li>
    </ul>
  </div>

  <div class="step">
    <h3>5) Sync album ➜ project folder (practical meaning)</h3>
    <p>Pick the album in Photos, upload through the Shortcut, and let the API de-dupe. For a future "true sync," send filename/size/date fingerprints and receive "upload-needed" decisions.</p>
  </div>

  <div class="step">
    <h3>6) Reindex after manual changes</h3>
    <p>Any time you drag, rename, or delete files manually, run:</p>
    <pre>curl -X POST http://127.0.0.1:8787/api/projects/P1-Public-Accountability/reindex</pre>
    <p>This reconciles disk ↔ sqlite, updates counts, and prunes missing records.</p>
  </div>

  <div class="step">
    <h3>7) Recommended daily workflow</h3>
    <ul>
      <li>Create/select project before recording.</li>
      <li>Use the Shortcut to push clips; let API de-dupe.</li>
      <li>Run <code>/reindex</code> if you reorganize manually.</li>
      <li>Use <code>_manifest/files.jsonl</code> for auditing.</li>
      <li>Treat <code>ingest/originals/</code> as the source of truth.</li>
    </ul>
  </div>

  <div class="step">
    <h3>8) Quick troubleshooting</h3>
    <ul>
      <li>iPhone cannot reach API: container must bind <code>0.0.0.0:8787</code> and firewall must allow it.</li>
      <li>Projects not appearing: verify the volume mount points to your Projects folder.</li>
      <li>Upload fails: file exceeds <code>MEDIA_SYNC_MAX_UPLOAD_MB</code> or extension unsupported.</li>
    </ul>
  </div>

  <div class="callout">
    Paste your <code>docker-compose.yaml</code> volume line and a sample project path if you need confirmation the mount is correct. The API will respond with guidance in <code>instructions</code> fields too.</div>

  <script>
    const projectsEl = document.getElementById('projects');
    const mediaEl = document.getElementById('media');
    const mediaList = document.getElementById('media-list');
    const mediaTitle = document.getElementById('media-title');
    const player = document.getElementById('player');
    const videoPlayer = document.getElementById('video-player');
    const mediaMeta = document.getElementById('media-meta');
    const sourcesEl = document.getElementById('sources');
    const sourceName = document.getElementById('source-name');
    const sourceRoot = document.getElementById('source-root');
    const sourceType = document.getElementById('source-type');
    const sourceAdd = document.getElementById('source-add');
    const sourceStatus = document.getElementById('source-status');
    const uploadPanel = document.getElementById('upload');
    const uploadCaption = document.getElementById('upload-caption');
    const uploadFile = document.getElementById('upload-file');
    const uploadPicker = document.getElementById('upload-picker');
    const uploadButton = document.getElementById('upload-button');
    const uploadStatus = document.getElementById('upload-status');

    let activeProject = null;

    async function loadSources() {
      sourcesEl.textContent = 'Loading sources...';
      try {
        const response = await fetch('/api/sources');
        if (!response.ok) throw new Error('Failed to list sources');
        const sources = await response.json();
        renderSources(sources);
      } catch (err) {
        sourcesEl.textContent = `Error loading sources: ${err.message}`;
      }
    }

    function renderSources(sources) {
      sourcesEl.textContent = '';
      if (!sources.length) {
        sourcesEl.textContent = 'Only the primary source is available — add another path below.';
        return;
      }
      sources.forEach((source) => {
        const card = document.createElement('div');
        const reachability = source.accessible ? 'reachable' : 'unreachable (check mount)';
        const enabled = source.enabled ? 'enabled' : 'disabled';
        card.innerHTML = `<strong>${source.name}</strong><br />`
          + `<span class="muted">${source.root}</span><br />`
          + `${enabled} • ${reachability}`;
        sourcesEl.appendChild(card);
      });
    }

    async function loadProjects() {
      projectsEl.textContent = 'Loading projects...';
      try {
        const response = await fetch('/api/projects');
        if (!response.ok) throw new Error('Failed to list projects');
        const projects = await response.json();
        renderProjects(projects);
      } catch (err) {
        projectsEl.textContent = `Error: ${err.message}`;
      }
    }

    function renderProjects(projects) {
      if (!projects.length) {
        projectsEl.textContent = 'No projects yet — create one via /api/projects then refresh.';
        return;
      }
      projectsEl.textContent = '';
      projects.forEach((project) => {
        const pill = document.createElement('div');
        pill.className = 'pill';
        pill.textContent = `${project.name}`;
        pill.title = project.instructions || 'Browse media in this project';
        pill.onclick = () => selectProject(project);
        projectsEl.appendChild(pill);
      });
    }

    function selectProject(project) {
      activeProject = project;
      uploadPanel.classList.remove('hidden');
      mediaEl.classList.remove('hidden');
      mediaTitle.textContent = `Media in ${project.name}`;
      uploadCaption.textContent = `Upload to ${project.name} (${project.source})`;
      uploadStatus.textContent = '';
      uploadFile.value = '';
      loadMedia();
    }

    async function loadMedia() {
      if (!activeProject) {
        mediaList.textContent = 'Select a project to view media.';
        return;
      }
      const { name, source } = activeProject;
      mediaList.textContent = 'Loading media...';
      mediaEl.classList.remove('hidden');
      player.classList.add('hidden');
      videoPlayer.pause();
      videoPlayer.removeAttribute('src');
      mediaTitle.textContent = `Media in ${name}`;
      const query = source ? `?source=${encodeURIComponent(source)}` : '';
      try {
        const response = await fetch(`/api/projects/${encodeURIComponent(name)}/media${query}`);
        if (!response.ok) throw new Error('Failed to load media list');
        const payload = await response.json();
        renderMedia(payload.media);
      } catch (err) {
        mediaList.textContent = `Error loading media: ${err.message}`;
      }
    }

    function renderMedia(items) {
      mediaList.textContent = '';
      if (!items.length) {
        mediaList.textContent = 'No indexed files yet. Upload then run /reindex.';
        return;
      }
      items.forEach((item) => {
        const row = document.createElement('div');
        row.className = 'media-row';

        const label = document.createElement('div');
        label.textContent = item.relative_path;

        const actions = document.createElement('div');
        actions.className = 'media-actions';
        const play = document.createElement('button');
        play.textContent = 'Play';
        play.onclick = () => playMedia(item.stream_url, item);
        actions.appendChild(play);

        row.appendChild(label);
        row.appendChild(actions);
        mediaList.appendChild(row);
      });
    }

    function playMedia(url, item) {
      player.classList.remove('hidden');
      videoPlayer.src = url;
      videoPlayer.load();
      mediaMeta.textContent = `${item.relative_path} • ${item.size || 0} bytes`;
    }

    function openPicker() {
      if (!uploadFile) return;
      if (typeof uploadFile.showPicker === 'function') {
        uploadFile.showPicker();
      } else {
        uploadFile.click();
      }
    }

    sourceAdd.addEventListener('click', async () => {
      sourceStatus.textContent = '';
      const name = (sourceName.value || '').trim();
      const root = (sourceRoot.value || '').trim();
      const type = (sourceType.value || 'local').trim() || 'local';
      if (!name || !root) {
        sourceStatus.textContent = 'Name and root are required to add a source.';
        return;
      }
      try {
        const response = await fetch('/api/sources', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, root, type, enabled: true }),
        });
        const payload = await response.json();
        if (!response.ok) {
          const detail = payload.detail || payload.message || 'Failed to save source';
          throw new Error(detail);
        }
        sourceStatus.textContent = `Saved source ${payload.name}.`;
        sourceName.value = '';
        sourceRoot.value = '';
        sourceType.value = '';
        loadSources();
      } catch (err) {
        sourceStatus.textContent = `Source save failed: ${err.message}`;
      }
    });

    uploadPicker.addEventListener('click', () => {
      uploadStatus.textContent = '';
      openPicker();
    });

    uploadButton.addEventListener('click', async () => {
      if (!activeProject) {
        uploadStatus.textContent = 'Choose a project before uploading.';
        return;
      }
      if (!uploadFile.files.length) {
        uploadStatus.textContent = 'Pick a file to upload first.';
        openPicker();
        return;
      }
      const form = new FormData();
      form.append('file', uploadFile.files[0]);
      uploadButton.disabled = true;
      uploadStatus.textContent = 'Uploading...';
      try {
        const targetUrl = activeProject.upload_url || `/api/projects/${encodeURIComponent(activeProject.name)}/upload?source=${encodeURIComponent(activeProject.source || '')}`;
        const response = await fetch(targetUrl, { method: 'POST', body: form });
        const payload = await response.json();
        if (!response.ok) {
          const detail = payload.detail || payload.message || 'Upload failed';
          throw new Error(detail);
        }
        uploadStatus.textContent = payload.status === 'duplicate'
          ? 'Duplicate skipped — already on disk.'
          : 'Upload stored. Run /reindex if you moved files manually.';
        loadMedia();
      } catch (err) {
        uploadStatus.textContent = `Upload failed: ${err.message}`;
      } finally {
        uploadButton.disabled = false;
      }
    });

    document.addEventListener('DOMContentLoaded', () => {
      loadSources();
      loadProjects();
    });
  </script>
</body>
</html>
