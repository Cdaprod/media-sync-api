<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>media-sync-api adapter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light;
      --bg: #f8fafc;
      --panel: #ffffff;
      --muted: #475569;
      --border: #e2e8f0;
      --accent: #6366f1;
      --accent-strong: #4338ca;
      --text: #0f172a;
    }

    body { font-family: Arial, sans-serif; margin: 2rem; line-height: 1.6; color: var(--text); background: var(--bg); }
    code { background: #e2e8f0; padding: 0.15rem 0.35rem; border-radius: 4px; }
    pre { background: #0f172a; color: #e2e8f0; padding: 1rem; border-radius: 6px; overflow-x: auto; }
    h1, h2, h3 { color: #0b132b; margin-top: 0; }
    .callout { background: #eef2ff; border: 1px solid #c7d2fe; border-radius: 10px; padding: 1rem 1.25rem; margin: 1rem 0; }
    .step { margin-bottom: 1.25rem; }
    ul { margin-top: 0.35rem; }
    .panel { border: 1px solid var(--border); border-radius: 10px; padding: 1rem; margin: 0.75rem 0; background: var(--panel); }
    .hidden { display: none; }
    .muted { color: var(--muted); font-size: 0.95rem; }
    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }

    .explorer-shell { display: grid; grid-template-columns: 280px 1fr; gap: 1rem; align-items: start; }
    .explorer-sidebar { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 1rem; box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08); }
    .sidebar-header { display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; margin-bottom: 0.75rem; }
    .sidebar-title { font-size: 1.1rem; font-weight: 700; }
    .search { width: 100%; padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: #f4f5fb; box-sizing: border-box; }
    .sidebar-block { margin-bottom: 1rem; }
    .section-title { font-size: 0.95rem; font-weight: 700; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.5rem; }
    .badge { background: #e0e7ff; color: #312e81; border-radius: 999px; padding: 0.15rem 0.6rem; font-size: 0.8rem; }
    .pill-list { display: flex; flex-direction: column; gap: 0.5rem; max-height: 220px; overflow-y: auto; }
    .pill { display: flex; align-items: center; justify-content: space-between; padding: 0.55rem 0.7rem; border-radius: 10px; background: #f8fafc; color: #0f172a; border: 1px solid var(--border); cursor: pointer; transition: background 120ms ease, border-color 120ms ease; }
    .pill:hover, .pill.active { background: #eef2ff; border-color: #c7d2fe; }
    .pill .subtext { color: var(--muted); font-size: 0.85rem; }

    .sources-grid { display: grid; grid-template-columns: 1fr; gap: 0.5rem; }
    .source-card { padding: 0.5rem 0.65rem; border: 1px solid var(--border); border-radius: 8px; background: #f8fafc; font-size: 0.95rem; }
    .source-status { display: inline-flex; gap: 0.25rem; align-items: center; color: #047857; font-weight: 600; font-size: 0.8rem; text-transform: uppercase; }
    .source-status.disabled { color: #b91c1c; }

    .source-form label { display: block; margin-bottom: 0.25rem; font-size: 0.9rem; }
    .source-form input { width: 100%; padding: 0.4rem 0.5rem; margin-top: 0.15rem; box-sizing: border-box; border-radius: 8px; border: 1px solid var(--border); }
    .source-form button { margin-top: 0.35rem; padding: 0.45rem 0.75rem; border: none; background: var(--accent); color: white; border-radius: 8px; cursor: pointer; }
    .source-form button:hover { background: var(--accent-strong); }

    .explorer-main { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 1rem; min-height: 540px; box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08); display: flex; flex-direction: column; gap: 0.75rem; }
    .explorer-main.drag-active { outline: 2px dashed var(--accent); outline-offset: -6px; background: #eef2ff; }
    .main-top { display: flex; justify-content: space-between; align-items: center; gap: 1rem; flex-wrap: wrap; }
    .main-top h3 { margin: 0; }
    .crumb { color: var(--muted); font-size: 0.95rem; }
    .actions-row { display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
    .btn { border: 1px solid var(--border); padding: 0.5rem 0.85rem; border-radius: 10px; background: #eef2ff; color: #1e3a8a; cursor: pointer; font-weight: 600; }
    .btn.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
    .btn.primary:hover { background: var(--accent-strong); }
    .btn:hover { background: #e0e7ff; }

    .upload-panel { padding: 0.75rem; border: 1px dashed var(--border); border-radius: 10px; background: #f8fafc; margin: 0; }
    .upload-panel button { padding: 0.4rem 0.75rem; border: none; background: #047857; color: white; border-radius: 8px; cursor: pointer; }
    .upload-panel button:hover { background: #065f46; }

    .file-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(230px, 1fr)); gap: 0.75rem; }
    .file-card { border: 1px solid var(--border); border-radius: 10px; padding: 0.75rem; background: #f8fafc; display: flex; flex-direction: column; gap: 0.35rem; justify-content: space-between; min-height: 150px; }
    .file-card .name { font-weight: 700; word-break: break-word; }
    .file-card .meta { color: var(--muted); font-size: 0.9rem; }
    .file-card.selected { outline: 2px solid var(--accent); outline-offset: 1px; }
    .file-actions { display: flex; justify-content: space-between; align-items: center; gap: 0.4rem; flex-wrap: wrap; }
    .menu { position: relative; }
    .menu button { background: #e2e8f0; border: 1px solid var(--border); border-radius: 8px; padding: 0.35rem 0.6rem; cursor: pointer; }
    .menu button:hover { background: #c7d2fe; }
    .menu-list { position: absolute; right: 0; top: 110%; border: 1px solid var(--border); border-radius: 8px; background: white; min-width: 180px; box-shadow: 0 8px 18px rgba(15, 23, 42, 0.1); padding: 0.25rem 0; z-index: 10; }
    .menu-list.hidden { display: none; }
    .menu-list button, .menu-list a { display: block; width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: transparent; cursor: pointer; color: var(--text); text-decoration: none; }
    .menu-list button:hover, .menu-list a:hover { background: #eef2ff; }

    .resolve-panel { border: 1px solid var(--border); border-radius: 10px; padding: 0.75rem; background: #f8fafc; }

    .empty-state { padding: 1.25rem; border: 1px dashed var(--border); border-radius: 10px; text-align: center; color: var(--muted); }

    @media (max-width: 960px) {
      body { margin: 1rem; }
      .explorer-shell { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <h1>media-sync-api</h1>
  <p>This lightweight, LAN-only API sits between your phone and host project storage. Mount <code>../Projects</code> on the host to <code>/data/projects</code> in the container, then use the endpoints below or the iPhone Shortcut flow to ingest media reliably.</p>

  <div class="callout">
    <strong>New: unified asset explorer</strong><br />
    Browse sources, projects, and indexed media from a single split-pane layout. Use per-file menus to preview, download, or queue clips for Resolve.
  </div>

  <div class="callout">
    <strong>API reference &amp; OpenAPI</strong><br />
    Interactive docs: <code><a href="/docs" target="_blank" rel="noreferrer">/docs</a></code><br />
    OpenAPI JSON: <code><a href="/openapi.json" target="_blank" rel="noreferrer">/openapi.json</a></code><br />
    Use the curl examples below to match the exact request shapes used by both explorers.
  </div>

  <div class="explorer-shell" id="browser-explorer">
    <aside class="explorer-sidebar">
      <div class="sidebar-header">
        <div class="sidebar-title">Asset Explorer</div>
      </div>
      <input id="asset-filter" class="search" placeholder="Search assets, tags, names" aria-label="Filter assets" />

      <div class="sidebar-block">
        <div class="section-title">Sources <span class="badge" aria-live="polite">active</span></div>
        <div id="sources" class="sources-grid"></div>
      </div>

      <div class="sidebar-block">
        <div class="section-title">Projects <span class="badge" aria-live="polite">folders</span></div>
        <div id="projects" class="pill-list" aria-live="polite"></div>
      </div>

      <div class="sidebar-block">
        <div class="section-title">Tags</div>
        <p class="muted">Tag filtering will use project metadata; for now, use the search box above to narrow files.</p>
      </div>

      <div class="sidebar-block">
        <div class="section-title">Add a source</div>
        <div class="source-form" aria-live="polite">
          <label for="source-name">Name</label>
          <input id="source-name" name="source-name" placeholder="nas" />
          <label for="source-root">Absolute path on host</label>
          <input id="source-root" name="source-root" placeholder="/mnt/nas/projects" />
          <label for="source-type">Type (optional)</label>
          <input id="source-type" name="source-type" placeholder="local|smb|nfs" />
          <button id="source-add" type="button">Save source</button>
          <div id="source-status" class="muted"></div>
        </div>
      </div>
    </aside>

    <div id="media" class="explorer-main">
      <div class="main-top">
        <div>
          <h3 id="media-title">Browse projects</h3>
          <div id="crumb-text" class="crumb">Select a folder on the left to view its contents.</div>
        </div>
        <div class="actions-row">
          <span id="selection-status" class="muted">Select clips to send to Resolve.</span>
        </div>
      </div>

      <div id="upload" class="upload-panel hidden" aria-live="polite">
        <p class="muted" id="upload-caption">Select a project to upload media.</p>
        <input type="file" id="upload-file" class="visually-hidden" aria-label="Select media to upload" />
        <div class="actions-row">
          <button id="upload-picker" type="button">Choose file</button>
          <button id="upload-button" type="button">Upload</button>
        </div>
        <div id="upload-status" class="muted"></div>
      </div>

      <div id="resolve-panel" class="resolve-panel hidden" aria-live="polite">
        <h4>DaVinci Resolve bridge</h4>
        <p class="muted">Select clips, then send them to the Resolve host agent to open/import.</p>
        <label for="resolve-project-mode">Project</label>
        <select id="resolve-project-mode">
          <option value="current">Use current project</option>
          <option value="__select__">Let host choose</option>
          <option value="__new__">Create new project</option>
        </select>
        <label for="resolve-project-name">Project name (override existing)</label>
        <input id="resolve-project-name" placeholder="P1-Public-Accountability" />
        <label for="resolve-new-name">New project name (if creating)</label>
        <input id="resolve-new-name" placeholder="P3-Editorial" />
        <label for="resolve-mode">Action</label>
        <select id="resolve-mode">
          <option value="import">Import into media pool</option>
          <option value="reveal_in_explorer">Reveal in Explorer/Finder</option>
        </select>
        <div class="actions-row">
          <button id="resolve-send" type="button" class="btn primary">Open in DaVinci Resolve</button>
          <div id="resolve-status" class="muted"></div>
        </div>
      </div>

      <div id="media-list" class="file-grid" aria-live="polite"></div>

      <div id="player" class="panel hidden">
        <h4>Preview</h4>
        <video id="video-player" controls style="max-width: 100%; height: auto;" aria-label="Media preview"></video>
        <p id="media-meta"></p>
      </div>
    </div>
  </div>

  <div class="callout">
    <strong>Host/LAN defaults</strong><br />
    API: <code>http://192.168.0.25:8787</code><br />
    Projects root: Host <code>B:\Video\Projects</code> → Container <code>/data/projects</code>
  </div>

  <h2>Playbook: verify → create projects → ingest → dedupe → reindex</h2>

  <div class="step">
    <h3>1) Verify it is running and see the schema</h3>
    <ul>
      <li>Health: <code>http://192.168.0.25:8787/health</code></li>
      <li>OpenAPI: <code>http://192.168.0.25:8787/openapi.json</code></li>
      <li>Docs UI: <code>http://192.168.0.25:8787/docs</code></li>
    </ul>
    <pre>curl http://192.168.0.25:8787/health
curl http://192.168.0.25:8787/openapi.json</pre>
    <p>If <code>/api/projects</code> returns an empty list, create one and confirm <code>index.json</code>, <code>ingest/</code>, and <code>_manifest/</code> exist under <code>../Projects/&lt;project&gt;</code> on the host.</p>
  </div>

  <div class="step">
    <h3>2) Create your first project (API)</h3>
    <p>Use curl from the host:</p>
    <pre>curl -X POST http://127.0.0.1:8787/api/projects \
  -H "Content-Type: application/json" \
  -d "{\"name\":\"P1-Public-Accountability\",\"notes\":\"Main production ingest\"}"</pre>
    <p>Then confirm: <code>curl http://127.0.0.1:8787/api/projects</code></p>
  </div>

  <div class="step">
    <h3>3) Upload, list, stream, and download media</h3>
    <pre>curl -X POST http://127.0.0.1:8787/api/projects/P1-Public-Accountability/upload \
  -F "file=@/path/to/clip.mov"
curl http://127.0.0.1:8787/api/projects/P1-Public-Accountability/media
curl http://127.0.0.1:8787/media/P1-Public-Accountability/ingest/originals/clip.mov
curl -OJ http://127.0.0.1:8787/media/P1-Public-Accountability/download/ingest/originals/clip.mov</pre>
    <p>Listing entries include <code>stream_url</code> and <code>download_url</code> for the explorers.</p>
  </div>

  <div class="step">
    <h3>4) Move or delete media (project-to-project)</h3>
    <pre>curl -X POST http://127.0.0.1:8787/api/projects/P1-Public-Accountability/media/move \
  -H "Content-Type: application/json" \
  -d '{"relative_paths":["ingest/originals/clip.mov"],"target_project":"P2-Editing"}'
curl -X POST http://127.0.0.1:8787/api/projects/P1-Public-Accountability/media/delete \
  -H "Content-Type: application/json" \
  -d '{"relative_paths":["ingest/originals/clip.mov"]}'</pre>
    <p>Moves update both project indexes and manifests; deletes remove files from disk and index.</p>
  </div>

  <div class="step">
    <h3>5) iPhone Shortcut outline</h3>
    <p>Select project → optional create → prompt for label → pick videos → upload → optional sync log.</p>
    <ol>
      <li>GET <code>/api/projects</code> → build list (append "➕ Create New Project").</li>
      <li>If creating: POST <code>/api/projects</code> with <code>{ "name": NewName, "notes": Notes }</code>.</li>
      <li>Ask for input <em>EntryLabel</em>, choose videos.</li>
      <li>Optional audit: POST <code>/api/projects/{Project}/sync-album</code> with JSON <code>{ "album_name": EntryLabel, "device": "iphone", "note": "Shortcut ingest" }</code>.</li>
      <li>For each file: POST <code>/api/projects/{Project}/upload</code> form field <code>file</code>.</li>
    </ol>
    <p>No duplicate handling is needed client-side—the API hashes and skips repeats automatically.</p>
  </div>

  <div class="step">
    <h3>6) Prove de-dupe is working</h3>
    <p>Upload 2–3 videos, then run the Shortcut again selecting the same files. Expected:</p>
    <ul>
      <li>Second run returns <code>"status": "duplicate"</code>.</li>
      <li><code>index.json</code> increments <code>duplicates_skipped</code>.</li>
      <li>No new media is stored.</li>
    </ul>
  </div>

  <div class="step">
    <h3>7) Sync album ➜ project folder (practical meaning)</h3>
    <p>Pick the album in Photos, upload through the Shortcut, and let the API de-dupe. For a future "true sync," send filename/size/date fingerprints and receive "upload-needed" decisions.</p>
  </div>

  <div class="step">
    <h3>8) Reindex after manual changes</h3>
    <p>Any time you drag, rename, or delete files manually, run:</p>
    <pre>curl -X POST http://127.0.0.1:8787/api/projects/P1-Public-Accountability/reindex</pre>
    <p>This reconciles disk ↔ sqlite, updates counts, and prunes missing records.</p>
  </div>

  <div class="step">
    <h3>9) Recommended daily workflow</h3>
    <ul>
      <li>Create/select project before recording.</li>
      <li>Use the Shortcut to push clips; let API de-dupe.</li>
      <li>Run <code>/reindex</code> if you reorganize manually.</li>
      <li>Use <code>_manifest/files.jsonl</code> for auditing.</li>
      <li>Treat <code>ingest/originals/</code> as the source of truth.</li>
    </ul>
  </div>

  <div class="step">
    <h3>10) Quick troubleshooting</h3>
    <ul>
      <li>iPhone cannot reach API: container must bind <code>0.0.0.0:8787</code> and firewall must allow it.</li>
      <li>Projects not appearing: verify the volume mount points to your Projects folder.</li>
      <li>Upload fails: file exceeds <code>MEDIA_SYNC_MAX_UPLOAD_MB</code> or extension unsupported.</li>
    </ul>
  </div>

  <div class="callout">
    Paste your <code>docker-compose.yaml</code> volume line and a sample project path if you need confirmation the mount is correct. The API will respond with guidance in <code>instructions</code> fields too.</div>

  <script>
    const projectsEl = document.getElementById('projects');
    const mediaEl = document.getElementById('media');
    const mediaList = document.getElementById('media-list');
    const mediaTitle = document.getElementById('media-title');
    const player = document.getElementById('player');
    const videoPlayer = document.getElementById('video-player');
    const mediaMeta = document.getElementById('media-meta');
    const sourcesEl = document.getElementById('sources');
    const sourceName = document.getElementById('source-name');
    const sourceRoot = document.getElementById('source-root');
    const sourceType = document.getElementById('source-type');
    const sourceAdd = document.getElementById('source-add');
    const sourceStatus = document.getElementById('source-status');
    const uploadPanel = document.getElementById('upload');
    const uploadCaption = document.getElementById('upload-caption');
    const uploadFile = document.getElementById('upload-file');
    const uploadPicker = document.getElementById('upload-picker');
    const uploadButton = document.getElementById('upload-button');
    const uploadStatus = document.getElementById('upload-status');
    const resolvePanel = document.getElementById('resolve-panel');
    const resolveProjectMode = document.getElementById('resolve-project-mode');
    const resolveProjectName = document.getElementById('resolve-project-name');
    const resolveNewName = document.getElementById('resolve-new-name');
    const resolveMode = document.getElementById('resolve-mode');
    const resolveSend = document.getElementById('resolve-send');
    const resolveStatus = document.getElementById('resolve-status');
    const selectionStatus = document.getElementById('selection-status');
    const assetFilter = document.getElementById('asset-filter');
    const crumbText = document.getElementById('crumb-text');

    let activeProject = null;
    const selectedMedia = new Set();
    let currentMedia = [];
    let mediaScope = 'project';

    const formatBytes = (bytes) => {
      if (!bytes || Number.isNaN(bytes)) return '0 B';
      const units = ['B', 'KB', 'MB', 'GB'];
      const power = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
      const size = bytes / (1024 ** power);
      return `${size.toFixed(size >= 10 ? 0 : 1)} ${units[power]}`;
    };

    const parseTimestamp = (value) => {
      if (!value) return 0;
      const ts = Date.parse(value);
      return Number.isNaN(ts) ? 0 : ts;
    };

    const filenameTimestamp = (relativePath) => {
      if (!relativePath) return 0;
      const name = relativePath.split('/').pop() || relativePath;
      const dateTimeMatch = name.match(/(\d{4})-(\d{2})-(\d{2})[T_ -]?(\d{2})-(\d{2})-(\d{2})/);
      if (dateTimeMatch) {
        const [, year, month, day, hour, minute, second] = dateTimeMatch;
        return Date.parse(`${year}-${month}-${day}T${hour}:${minute}:${second}`);
      }
      const dateMatch = name.match(/(\d{4})-(\d{2})-(\d{2})/);
      if (dateMatch) {
        const [, year, month, day] = dateMatch;
        return Date.parse(`${year}-${month}-${day}T00:00:00`);
      }
      return 0;
    };

    const itemTimestamp = (item) => Math.max(
      parseTimestamp(item.updated_at),
      parseTimestamp(item.updatedAt),
      parseTimestamp(item.created_at),
      parseTimestamp(item.createdAt),
      parseTimestamp(item.uploaded_at),
      parseTimestamp(item.uploadedAt),
      parseTimestamp(item.indexed_at),
      parseTimestamp(item.indexedAt),
      filenameTimestamp(item.relative_path),
    );

    const sortMediaByRecent = (items) => items.slice().sort((a, b) => {
      const delta = itemTimestamp(b) - itemTimestamp(a);
      if (delta !== 0) return delta;
      return String(b.relative_path || '').localeCompare(String(a.relative_path || ''));
    });

    const projectLabel = (item) => {
      if (!item.project_name) return '';
      return item.project_source ? `${item.project_name} (${item.project_source})` : item.project_name;
    };

    const toAbsoluteUrl = (path) => {
      if (!path) return '';
      if (path.startsWith('http://') || path.startsWith('https://')) {
        return path;
      }
      return new URL(path, window.location.origin).toString();
    };

    const copyTextWithFallback = async (text) => {
      if (!text) return false;
      if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (err) {
          // fallback continues below
        }
      }
      const temp = document.createElement('textarea');
      temp.value = text;
      temp.setAttribute('readonly', '');
      temp.style.position = 'fixed';
      temp.style.top = '-1000px';
      temp.style.left = '-1000px';
      document.body.appendChild(temp);
      temp.focus();
      temp.select();
      let ok = false;
      try {
        ok = document.execCommand('copy');
      } catch (err) {
        ok = false;
      }
      temp.remove();
      if (ok) return true;
      if (typeof window.prompt === 'function') {
        window.prompt('Copy to clipboard', text);
        return true;
      }
      return false;
    };

    const dragPayload = (item) => {
      const paths = selectedMedia.has(item.relative_path)
        ? Array.from(selectedMedia)
        : [item.relative_path];
      return JSON.stringify({ paths });
    };

    const attachDragData = (event, item) => {
      if (!event.dataTransfer || !item) return;
      event.dataTransfer.setData('application/x-media-sync', dragPayload(item));
      const downloadUrl = toAbsoluteUrl(item.download_url || item.stream_url || '');
      if (downloadUrl) {
        const filename = item.relative_path.split('/').pop() || 'media';
        event.dataTransfer.setData('DownloadURL', `application/octet-stream:${filename}:${downloadUrl}`);
        event.dataTransfer.setData('text/uri-list', downloadUrl);
      }
      event.dataTransfer.effectAllowed = 'move';
    };

    async function loadSources() {
      sourcesEl.textContent = 'Loading sources...';
      try {
        const response = await fetch('/api/sources');
        if (!response.ok) throw new Error('Failed to list sources');
        const sources = await response.json();
        renderSources(sources);
      } catch (err) {
        sourcesEl.textContent = `Error loading sources: ${err.message}`;
      }
    }

    function renderSources(sources) {
      sourcesEl.textContent = '';
      if (!sources.length) {
        sourcesEl.textContent = 'Only the primary source is available — add another path below.';
        return;
      }
      sources.forEach((source) => {
        const card = document.createElement('div');
        card.className = 'source-card';
        const reachability = source.accessible ? 'reachable' : 'unreachable (check mount)';
        const enabled = source.enabled ? 'enabled' : 'disabled';
        card.innerHTML = `<strong>${source.name}</strong><br />`
          + `<span class="muted">${source.root}</span><br />`
          + `<span class="source-status ${source.enabled ? '' : 'disabled'}">${enabled}</span>`
          + ` • ${reachability}`;
        sourcesEl.appendChild(card);
      });
    }

    async function loadProjects() {
      projectsEl.textContent = 'Loading projects...';
      try {
        const response = await fetch('/api/projects');
        if (!response.ok) throw new Error('Failed to list projects');
        const projects = await response.json();
        renderProjects(projects);
        if (!activeProject) {
          await loadAllMedia(projects);
        }
      } catch (err) {
        projectsEl.textContent = `Error: ${err.message}`;
      }
    }

    function renderProjects(projects) {
      projectsEl.textContent = '';
      if (!projects.length) {
        projectsEl.textContent = 'No projects yet — create one via /api/projects then refresh.';
        return;
      }
      projects.forEach((project) => {
        const pill = document.createElement('div');
        pill.className = 'pill';
        if (activeProject && activeProject.name === project.name) {
          pill.classList.add('active');
        }
        const label = document.createElement('div');
        label.textContent = project.name;
        const sub = document.createElement('div');
        sub.className = 'subtext';
        sub.textContent = project.source || 'primary';
        pill.title = project.instructions || 'Browse media in this project';
        pill.appendChild(label);
        pill.appendChild(sub);
        pill.onclick = () => selectProject(project);
        pill.addEventListener('dragover', (event) => {
          event.preventDefault();
          event.dataTransfer.dropEffect = 'move';
        });
        pill.addEventListener('drop', async (event) => {
          event.preventDefault();
          const raw = event.dataTransfer.getData('application/x-media-sync');
          if (!raw) return;
          try {
            const data = JSON.parse(raw);
            const paths = Array.isArray(data.paths) ? data.paths : [];
            if (!paths.length) return;
            await moveMedia(paths, project);
          } catch (err) {
            uploadStatus.textContent = `Move failed: ${err.message}`;
          }
        });
        projectsEl.appendChild(pill);
      });
    }

    function selectProject(project) {
      activeProject = project;
      mediaScope = 'project';
      selectedMedia.clear();
      updateSelectionStatus();
      uploadPanel.classList.remove('hidden');
      mediaEl.classList.remove('hidden');
      mediaTitle.textContent = `Media in ${project.name}`;
      crumbText.textContent = `${project.source || 'primary'} • ${project.name}`;
      uploadCaption.textContent = `Upload to ${project.name} (${project.source})`;
      uploadStatus.textContent = '';
      uploadFile.value = '';
      resolveProjectMode.value = 'current';
      resolveProjectName.value = project.name;
      resolveNewName.value = '';
      resolveStatus.textContent = '';
      resolvePanel.classList.remove('hidden');
      loadMedia();
      loadProjects();
    }

    async function loadMedia() {
      if (!activeProject) {
        mediaScope = 'project';
        mediaList.innerHTML = '<div class="empty-state">Select a project to view media.</div>';
        return;
      }
      const { name, source } = activeProject;
      mediaList.innerHTML = '<div class="empty-state">Loading media...</div>';
      mediaEl.classList.remove('hidden');
      player.classList.add('hidden');
      videoPlayer.pause();
      videoPlayer.removeAttribute('src');
      mediaMeta.textContent = '';
      mediaTitle.textContent = `Media in ${name}`;
      const query = source ? `?source=${encodeURIComponent(source)}` : '';
      try {
        const response = await fetch(`/api/projects/${encodeURIComponent(name)}/media${query}`);
        if (!response.ok) throw new Error('Failed to load media list');
        const payload = await response.json();
        mediaScope = 'project';
        currentMedia = sortMediaByRecent(payload.media || []);
        applyMediaFilter();
      } catch (err) {
        mediaList.innerHTML = `<div class="empty-state">Error loading media: ${err.message}</div>`;
      }
    }

    async function loadAllMedia(projects) {
      mediaScope = 'all';
      selectedMedia.clear();
      updateSelectionStatus();
      mediaEl.classList.remove('hidden');
      mediaTitle.textContent = 'Media — All Projects';
      crumbText.textContent = 'all projects';
      if (!projects.length) {
        currentMedia = [];
        applyMediaFilter();
        return;
      }
      const gathered = [];
      for (const project of projects) {
        const query = project.source ? `?source=${encodeURIComponent(project.source)}` : '';
        try {
          const response = await fetch(`/api/projects/${encodeURIComponent(project.name)}/media${query}`);
          if (!response.ok) throw new Error('Failed to load media list');
          const payload = await response.json();
          const media = payload.media || [];
          media.forEach((item) => gathered.push({
            ...item,
            project_name: project.name,
            project_source: project.source || null,
          }));
        } catch (err) {
          uploadStatus.textContent = `Skipped ${project.name}: ${err.message}`;
        }
      }
      currentMedia = sortMediaByRecent(gathered);
      applyMediaFilter();
    }

    function applyMediaFilter() {
      if (!activeProject && mediaScope !== 'all') {
        mediaList.innerHTML = '<div class="empty-state">Select a project to view media.</div>';
        return;
      }
      const term = (assetFilter.value || '').toLowerCase();
      const filtered = term
        ? currentMedia.filter((item) => (item.relative_path || '').toLowerCase().includes(term))
        : currentMedia.slice();
      renderMediaGrid(filtered);
    }

    function renderMediaGrid(items) {
      mediaList.textContent = '';
      if (!items.length) {
        mediaList.innerHTML = mediaScope === 'all'
          ? '<div class="empty-state">No assets found across all projects.</div>'
          : '<div class="empty-state">No assets found for this folder or filter.</div>';
        return;
      }

      items.forEach((item) => {
        const card = document.createElement('div');
        card.className = 'file-card';
        const isSelected = selectedMedia.has(item.relative_path);
        if (isSelected) card.classList.add('selected');
        if (activeProject) {
          card.setAttribute('draggable', 'true');
          card.addEventListener('dragstart', (event) => attachDragData(event, item));
        }

        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = item.relative_path.split('/').pop();

        const meta = document.createElement('div');
        meta.className = 'meta';
        const proj = projectLabel(item);
        meta.textContent = `${item.relative_path} • ${formatBytes(item.size || 0)}${proj ? ` • ${proj}` : ''}`;

        const actions = document.createElement('div');
        actions.className = 'file-actions';

        const preview = document.createElement('button');
        preview.className = 'btn primary';
        preview.textContent = 'Preview';
        preview.onclick = () => playMedia(item.stream_url, item);

        const queue = document.createElement('button');
        queue.className = 'btn';
        queue.textContent = isSelected ? 'Queued for Resolve' : 'Queue for Resolve';
        queue.onclick = () => {
          toggleSelection(item.relative_path, !selectedMedia.has(item.relative_path));
          card.classList.toggle('selected', selectedMedia.has(item.relative_path));
          queue.textContent = selectedMedia.has(item.relative_path) ? 'Queued for Resolve' : 'Queue for Resolve';
        };
        queue.disabled = !activeProject;

        const menu = document.createElement('div');
        menu.className = 'menu';
        const menuButton = document.createElement('button');
        menuButton.type = 'button';
        menuButton.textContent = '⋯';
        const menuList = document.createElement('div');
        menuList.className = 'menu-list hidden';

        const downloadUrl = item.download_url || item.stream_url;
        const download = document.createElement('a');
        download.href = downloadUrl;
        download.textContent = 'Download';
        download.setAttribute('download', '');

        const copyLink = document.createElement('button');
        copyLink.type = 'button';
        copyLink.textContent = 'Copy stream URL';
        copyLink.onclick = async () => {
          const text = toAbsoluteUrl(item.stream_url);
          const ok = await copyTextWithFallback(text);
          uploadStatus.textContent = ok
            ? 'Stream URL copied to clipboard.'
            : 'Copy failed — please copy the URL manually.';
        };

        const reveal = document.createElement('button');
        reveal.type = 'button';
        reveal.textContent = 'Preview & details';
        reveal.onclick = () => playMedia(item.stream_url, item);

        const deleteButton = document.createElement('button');
        deleteButton.type = 'button';
        deleteButton.textContent = 'Delete';
        deleteButton.onclick = async () => {
          await deleteMedia([item.relative_path]);
        };

        menuList.appendChild(reveal);
        menuList.appendChild(download);
        menuList.appendChild(copyLink);
        menuList.appendChild(deleteButton);
        menu.appendChild(menuButton);
        menu.appendChild(menuList);

        menuButton.addEventListener('click', (evt) => {
          evt.stopPropagation();
          menuList.classList.toggle('hidden');
        });
        menu.addEventListener('click', (evt) => evt.stopPropagation());
        document.addEventListener('click', () => menuList.classList.add('hidden'), { once: true });

        actions.appendChild(preview);
        actions.appendChild(queue);
        actions.appendChild(menu);

        card.appendChild(name);
        card.appendChild(meta);
        card.appendChild(actions);
        mediaList.appendChild(card);
      });
    }

    function playMedia(url, item) {
      if (!url) return;
      player.classList.remove('hidden');
      videoPlayer.src = url;
      videoPlayer.load();
      mediaMeta.textContent = `${item.relative_path} • ${formatBytes(item.size || 0)}`;
    }

    function openPicker() {
      if (!uploadFile) return;
      if (typeof uploadFile.showPicker === 'function') {
        uploadFile.showPicker();
      } else {
        uploadFile.click();
      }
    }

    function toggleSelection(path, checked) {
      if (!activeProject) return;
      if (checked) {
        selectedMedia.add(path);
      } else {
        selectedMedia.delete(path);
      }
      updateSelectionStatus();
    }

    function updateSelectionStatus() {
      if (!selectionStatus) return;
      const count = selectedMedia.size;
      if (!activeProject) {
        selectionStatus.textContent = 'Select a project to queue clips for Resolve.';
        return;
      }
      selectionStatus.textContent = count
        ? `${count} item(s) queued for Resolve.`
        : 'Select clips to send to Resolve.';
    }

    async function deleteMedia(paths) {
      if (!activeProject) {
        uploadStatus.textContent = 'Choose a project before deleting.';
        return;
      }
      if (!paths.length) {
        uploadStatus.textContent = 'Select one or more files to delete.';
        return;
      }
      const query = activeProject.source ? `?source=${encodeURIComponent(activeProject.source)}` : '';
      try {
        const response = await fetch(`/api/projects/${encodeURIComponent(activeProject.name)}/media/delete${query}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ relative_paths: paths }),
        });
        const payload = await response.json();
        if (!response.ok) {
          const detail = payload.detail || payload.message || 'Delete failed';
          throw new Error(detail);
        }
        uploadStatus.textContent = 'Media removed from disk and index.';
        paths.forEach((path) => selectedMedia.delete(path));
        updateSelectionStatus();
        loadMedia();
      } catch (err) {
        uploadStatus.textContent = `Delete failed: ${err.message}`;
      }
    }

    async function moveMedia(paths, targetProject) {
      if (!activeProject) return;
      if (!paths.length) return;
      const query = activeProject.source ? `?source=${encodeURIComponent(activeProject.source)}` : '';
      try {
        const response = await fetch(`/api/projects/${encodeURIComponent(activeProject.name)}/media/move${query}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            relative_paths: paths,
            target_project: targetProject.name,
            target_source: targetProject.source || null,
          }),
        });
        const payload = await response.json();
        if (!response.ok) {
          const detail = payload.detail || payload.message || 'Move failed';
          throw new Error(detail);
        }
        uploadStatus.textContent = `Moved ${paths.length} item(s) to ${targetProject.name}.`;
        paths.forEach((path) => selectedMedia.delete(path));
        updateSelectionStatus();
        loadMedia();
        loadProjects();
      } catch (err) {
        uploadStatus.textContent = `Move failed: ${err.message}`;
      }
    }

    async function sendToResolve() {
      resolveStatus.textContent = '';
      if (!activeProject) {
        resolveStatus.textContent = 'Choose a project first.';
        return;
      }
      if (!selectedMedia.size) {
        resolveStatus.textContent = 'Select one or more clips to send to Resolve.';
        return;
      }

      const projectMode = resolveProjectMode.value;
      let projectValue = activeProject.name;
      if (projectMode === '__new__') {
        projectValue = '__new__';
      } else if (projectMode === '__select__') {
        projectValue = '__select__';
      } else if (resolveProjectName.value) {
        projectValue = resolveProjectName.value.trim();
      }

      const body = {
        project: projectValue,
        new_project_name: projectMode === '__new__' ? resolveNewName.value.trim() || null : null,
        media_rel_paths: Array.from(selectedMedia),
        mode: resolveMode.value || 'import',
      };

      const sourceQuery = activeProject.source ? `?source=${encodeURIComponent(activeProject.source)}` : '';
      try {
        const res = await fetch(`/api/resolve/open${sourceQuery}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
        });
        const json = await res.json();
        if (!res.ok) {
          const detail = json.detail || json.message || 'Resolve request failed';
          throw new Error(detail);
        }
        resolveStatus.textContent = `Sent to Resolve host. Job: ${json.job_id}`;
      } catch (err) {
        resolveStatus.textContent = `Resolve request failed: ${err.message}`;
      }
    }

    sourceAdd.addEventListener('click', async () => {
      sourceStatus.textContent = '';
      const name = (sourceName.value || '').trim();
      const root = (sourceRoot.value || '').trim();
      const type = (sourceType.value || 'local').trim() || 'local';
      if (!name || !root) {
        sourceStatus.textContent = 'Name and root are required to add a source.';
        return;
      }
      try {
        const response = await fetch('/api/sources', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, root, type, enabled: true }),
        });
        const payload = await response.json();
        if (!response.ok) {
          const detail = payload.detail || payload.message || 'Failed to save source';
          throw new Error(detail);
        }
        sourceStatus.textContent = `Saved source ${payload.name}.`;
        sourceName.value = '';
        sourceRoot.value = '';
        sourceType.value = '';
        loadSources();
      } catch (err) {
        sourceStatus.textContent = `Source save failed: ${err.message}`;
      }
    });

    uploadPicker.addEventListener('click', () => {
      uploadStatus.textContent = '';
      openPicker();
    });

    uploadButton.addEventListener('click', async () => {
      if (!activeProject) {
        uploadStatus.textContent = 'Choose a project before uploading.';
        return;
      }
      if (!uploadFile.files.length) {
        uploadStatus.textContent = 'Pick a file to upload first.';
        openPicker();
        return;
      }
      await uploadFiles(uploadFile.files);
    });

    async function uploadFiles(files) {
      if (!activeProject) {
        uploadStatus.textContent = 'Choose a project before uploading.';
        return;
      }
      if (!files || !files.length) return;
      uploadButton.disabled = true;
      uploadStatus.textContent = 'Uploading...';
      try {
        const targetUrl = activeProject.upload_url || `/api/projects/${encodeURIComponent(activeProject.name)}/upload?source=${encodeURIComponent(activeProject.source || '')}`;
        for (const file of Array.from(files)) {
          const form = new FormData();
          form.append('file', file);
          const response = await fetch(targetUrl, { method: 'POST', body: form });
          const payload = await response.json();
          if (!response.ok) {
            const detail = payload.detail || payload.message || 'Upload failed';
            throw new Error(detail);
          }
        }
        uploadStatus.textContent = files.length > 1
          ? 'Uploads stored.'
          : 'Upload stored. Run /reindex if you moved files manually.';
        loadMedia();
      } catch (err) {
        uploadStatus.textContent = `Upload failed: ${err.message}`;
      } finally {
        uploadButton.disabled = false;
      }
    }

    resolveSend.addEventListener('click', () => {
      sendToResolve();
    });

    assetFilter.addEventListener('input', () => applyMediaFilter());

    mediaEl.addEventListener('dragover', (event) => {
      if (event.dataTransfer?.types?.includes('Files')) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
        mediaEl.classList.add('drag-active');
      }
    });
    mediaEl.addEventListener('dragleave', () => mediaEl.classList.remove('drag-active'));
    mediaEl.addEventListener('drop', async (event) => {
      if (!event.dataTransfer?.files?.length) return;
      event.preventDefault();
      mediaEl.classList.remove('drag-active');
      await uploadFiles(event.dataTransfer.files);
    });

    document.addEventListener('DOMContentLoaded', () => {
      loadSources();
      loadProjects();
      applyMediaFilter();
    });
  </script>
</body>
</html>
