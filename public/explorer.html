<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>media-sync-api ‚Äî Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg: #0b1020;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.09);
      --border: rgba(255,255,255,0.10);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --muted2: rgba(255,255,255,0.45);
      --brand: #7c3aed;   /* violet */
      --brand2:#22c55e;   /* green */
      --warn: #f59e0b;
      --bad:  #ef4444;
      --shadow: 0 16px 50px rgba(0,0,0,0.45);
      --radius: 18px;
      --radius2: 12px;
      --ring: 0 0 0 3px rgba(124,58,237,0.25);
      --ease-settle: cubic-bezier(0.2, 0.8, 0.2, 1);
      --ease-snappy: cubic-bezier(0.16, 1, 0.3, 1);
      --dur-fast: 160ms;
      --dur-med: 240ms;
      --dur-slow: 320ms;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      font-family: var(--sans);
      background:
        radial-gradient(1200px 600px at 10% 0%, rgba(124,58,237,0.25), transparent 60%),
        radial-gradient(1000px 500px at 90% 10%, rgba(34,197,94,0.18), transparent 55%),
        radial-gradient(900px 500px at 50% 90%, rgba(59,130,246,0.12), transparent 60%),
        var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    a { color: inherit; }
    code { font-family: var(--mono); }

    .app {
      height: 100%;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .mobile-only{ display:none; }

    .backdrop{
      position: fixed;
      inset:0;
      background: rgba(6,8,14,0.6);
      opacity:0;
      pointer-events:none;
      transition: opacity var(--dur-med) var(--ease-settle);
      z-index:65;
    }
    .backdrop.show{ opacity:1; pointer-events:auto; }
    #drawerBackdrop{
      background: rgba(6,8,14,0.35);
    }

    /* Top bar */
    .topbar{
      position: sticky;
      top:0;
      z-index: 40;
      background: rgba(11,16,32,0.9);
      border-bottom: 1px solid var(--border);
    }
    .topbar-inner{
      position: relative;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 16px;
      padding: 10px 18px;
      max-width: 1400px;
      margin: 0 auto;
    }
    .brand{
      display:flex;
      align-items:center;
      min-width: 0;
      max-width: 210px;
    }
    .brand-text{
      min-width: 0;
      display:flex;
      flex-direction: column;
      gap: 2px;
    }
    .brand h1{
      margin:0;
      font-size: 14px;
      letter-spacing: 0.35px;
      font-weight: 750;
      line-height: 1.1;
      color: var(--text);
      cursor: pointer;
      position: relative;
    }
    .brand h1 button{
      all: unset;
      cursor: pointer;
      display: inline-flex;
      position: relative;
    }
    .brand-title{
      display: inline-block;
      background: linear-gradient(120deg, #f0f3ff 5%, #a7d3ff 55%, #c6ffe2 90%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 4px 14px rgba(60,130,255,0.18);
      transition: transform var(--dur-med) var(--ease-snappy), opacity var(--dur-med) var(--ease-settle);
      will-change: transform, opacity;
    }
    .brand-title.is-secondary{
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      transform: translateY(8px);
      pointer-events: none;
    }
    .brand.projects-open .brand-title.is-primary{
      opacity: 0;
      transform: translateY(-8px);
    }
    .brand.projects-open .brand-title.is-secondary{
      opacity: 1;
      transform: translateY(0);
    }
    .brand .sub{
      margin:0;
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 180px;
    }

    .toolbar{
      display:flex;
      align-items:center;
      gap: 10px;
      flex: 1;
      justify-content: flex-end;
      min-width: 0;
    }
    .topbar-controls{
      display:flex;
      align-items:center;
      gap: 8px;
      min-width: 0;
    }

    .search{
      flex: 1;
      max-width: 420px;
      min-width: 180px;
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
    }
    .search input{
      width: 100%;
      border: none;
      outline: none;
      background: transparent;
      color: var(--text);
      font-size: 13px;
    }
    .search input::placeholder{ color: var(--muted2); }

    .pillbar{
      display:flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
    }
    .actions-panel{
      position: absolute;
      top: calc(100% + 8px);
      right: 18px;
      min-width: min(520px, 92vw);
      background: rgba(11,16,32,0.96);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 12px;
      display: none;
      flex-direction: column;
      gap: 10px;
      z-index: 75;
    }
    .actions-panel.open{ display:flex; }
    .btn{
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 12px;
      cursor:pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      user-select:none;
      display:flex;
      align-items:center;
      gap: 8px;
      white-space: nowrap;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,0.09); border-color: rgba(255,255,255,0.16); }
    .btn:active{ transform: translateY(0px); }
    .btn.primary{ border-color: rgba(124,58,237,0.45); background: rgba(124,58,237,0.18); }
    .btn.good{ border-color: rgba(34,197,94,0.45); background: rgba(34,197,94,0.14); }
    .btn.bad{ border-color: rgba(239,68,68,0.45); background: rgba(239,68,68,0.14); }
    .btn[disabled]{ opacity: 0.55; cursor: not-allowed; transform: none; }

    .seg{
      display:flex;
      border: 1px solid var(--border);
      border-radius: 999px;
      overflow:hidden;
      background: rgba(255,255,255,0.05);
    }
    .seg button{
      border: none;
      background: transparent;
      color: var(--muted);
      padding: 8px 10px;
      font-size: 12px;
      cursor:pointer;
    }
    .seg button.active{
      background: rgba(255,255,255,0.10);
      color: var(--text);
    }

    /* Main layout */
    .main{
      flex: 1;
      min-height: 0;
      display:flex;
      max-width: 1400px;
      width: 100%;
      margin: 0 auto;
      padding: 16px 18px 18px;
      gap: 14px;
    }

    .sidebar{
      width: 330px;
      min-width: 260px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--panel);
      box-shadow: var(--shadow);
      overflow: hidden;
      display:flex;
      flex-direction: column;
      min-height: 0;
      position: relative;
      z-index: 50;
    }

    .sidebar.sidebar-drawer{
      position: fixed;
      top: 70px;
      left: 0;
      height: calc(100% - 70px);
      width: min(420px, 100vw - 24px);
      max-width: 100%;
      transform: translateX(-105%);
      opacity: 0;
      transition: transform var(--dur-slow) var(--ease-settle), opacity var(--dur-med) var(--ease-settle);
      pointer-events: none;
      z-index: 90;
      will-change: transform, opacity;
    }
    .sidebar.sidebar-drawer.is-open{
      transform: translateX(0%);
      opacity: 1;
      pointer-events: auto;
    }

    .content{
      flex:1;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--panel);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction: column;
      min-height: 0;
    }
    .content.drag-active{
      outline: 2px dashed rgba(124,58,237,0.6);
      outline-offset: -6px;
      background: rgba(124,58,237,0.08);
    }

    .section-h{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .section-h h2{
      margin:0;
      font-size: 13px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .meta-line{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: rgba(255,255,255,0.06);
      color: var(--muted);
    }

    .scroll{
      overflow: auto;
      min-height: 0;
    }
    .scroll::-webkit-scrollbar{ width: 10px; height: 10px; }
    .scroll::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.14); border-radius: 999px; border: 2px solid rgba(0,0,0,0); background-clip: padding-box; }
    .scroll::-webkit-scrollbar-track{ background: rgba(255,255,255,0.04); }

    /* Project chips */
    .chips{
      padding: 12px;
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .chip{
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      cursor:pointer;
      transition: background 120ms ease, transform 120ms ease, border-color 120ms ease;
      max-width: 100%;
      display:flex;
      gap: 8px;
      align-items:center;
    }
    .chip:hover{ background: rgba(255,255,255,0.09); transform: translateY(-1px); }
    .chip.active{
      border-color: rgba(124,58,237,0.55);
      background: rgba(124,58,237,0.16);
      box-shadow: 0 0 0 3px rgba(124,58,237,0.12) inset;
    }
    .chip .dot{
      width: 8px; height: 8px; border-radius: 999px;
      background: rgba(255,255,255,0.25);
    }
    .chip.active .dot{
      background: linear-gradient(135deg, rgba(124,58,237,0.9), rgba(34,197,94,0.8));
    }
    .chip .name{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 250px;
    }

    /* Sources */
    .sources{
      padding: 12px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .card{
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      background: rgba(255,255,255,0.05);
      padding: 10px 10px;
    }
    .card strong { font-size: 12px; }
    .card .small { font-size: 11px; color: var(--muted); margin-top: 4px; }
    .tagrow{ display:flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
    .tag{
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      background: rgba(255,255,255,0.04);
    }
    .taglist{
      display:flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .taglist .tag{
      border-color: rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: var(--text);
    }
    .taglist .tag-button{
      border: 0;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-family: inherit;
    }
    .taglist .tag-button span{
      opacity: 0.7;
      font-size: 11px;
    }
    .tag.good{ border-color: rgba(34,197,94,0.35); color: rgba(187,247,208,0.85); background: rgba(34,197,94,0.12); }
    .tag.bad{ border-color: rgba(239,68,68,0.35); color: rgba(254,202,202,0.85); background: rgba(239,68,68,0.12); }
    .tag-panel{
      margin-top: 12px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
    }
    .tag-panel.is-hidden{
      display: none;
    }
    .drawer-tag-panel{
      position: absolute;
      left: 14px;
      right: 14px;
      top: 14px;
      z-index: 5;
      margin-top: 0;
      background: rgba(11,16,32,0.96);
      box-shadow: var(--shadow);
      display: none;
    }
    .drawer-tag-panel.open{
      display: block;
    }
    .drawer-tag-panel .taglist{
      max-height: 120px;
      overflow: auto;
    }
    .drawer-tag-panel .tag-editor{
      margin-top: 10px;
    }
    .drawer-body{
      position: relative;
    }
    .tag-editor{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
      align-items: center;
    }
    .tag-editor input{
      flex: 1 1 180px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      color: var(--text);
    }

    /* Grid/List */
    .grid{
      padding: 14px;
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 12px;
    }
    .list{
      padding: 10px 12px;
      display:flex;
      flex-direction: column;
      gap: 8px;
    }

    .asset{
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      border-radius: var(--radius2);
      overflow:hidden;
      cursor:pointer;
      transition: transform var(--dur-med) var(--ease-snappy), background var(--dur-med) var(--ease-settle), border-color var(--dur-med) var(--ease-settle);
      position: relative;
      will-change: transform;
    }
    .asset:hover{ transform: translateY(-3px) scale(1.01); background: rgba(255,255,255,0.07); border-color: rgba(255,255,255,0.16); }

    .thumb{
      aspect-ratio: 5/4;
      background: rgba(255,255,255,0.04);
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:center;
      position: relative;
      overflow:hidden;
    }
    .thumb img{
      width: 100%; height: 100%;
      object-fit: cover;
      display:block;
      filter: saturate(1.05) contrast(1.03);
    }
    .thumb .fallback{
      font-size: 12px;
      color: var(--muted);
      padding: 14px;
      text-align:center;
    }

    .asset .body{
      padding: 8px 10px 10px;
      display:flex;
      flex-direction: column;
      gap: 6px;
    }
    .asset .title{
      font-size: 12px;
      font-weight: 650;
      line-height: 1.25;
      overflow:hidden;
      display:-webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    .asset .sub{
      font-size: 11px;
      color: var(--muted);
      overflow:hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .badges{
      position:absolute;
      top: 10px; left: 10px;
      display:flex;
      gap: 6px;
      flex-wrap: wrap;
      max-width: calc(100% - 20px);
    }
    .badge{
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.25);
      color: rgba(255,255,255,0.85);
    }
    .badge.kind-video{ border-color: rgba(59,130,246,0.35); }
    .badge.kind-image{ border-color: rgba(34,197,94,0.35); }
    .badge.kind-audio{ border-color: rgba(245,158,11,0.35); }
    .badge.kind-doc{ border-color: rgba(124,58,237,0.35); }

    .selector{
      position:absolute;
      top: 10px; right: 10px;
      width: 34px; height: 34px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.25);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .selector input{ width: 16px; height: 16px; }

    .asset.selected{
      border-color: rgba(124,58,237,0.55);
      box-shadow: 0 0 0 3px rgba(124,58,237,0.12) inset;
      transform: translateY(-1px);
    }

    /* List row variant */
    .row{
      display:flex;
      gap: 10px;
      align-items:center;
      padding: 10px 10px;
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      background: rgba(255,255,255,0.05);
    }
    .row:hover{ border-color: rgba(255,255,255,0.16); background: rgba(255,255,255,0.07); }
    .row .mini{
      width: 86px; height: 54px;
      border-radius: 12px;
      border: 1px solid var(--border);
      overflow:hidden;
      background: rgba(255,255,255,0.04);
      flex-shrink:0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .row .mini img{ width:100%; height:100%; object-fit: cover; display:block; }
    .row .info{ flex:1; min-width:0; }
    .row .info .t{ font-size: 12px; font-weight: 650; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .row .info .s{ font-size: 11px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 4px; }
    .row .actions{ display:flex; align-items:center; gap: 8px; }
    .iconbtn{
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      cursor:pointer;
    }
    .iconbtn:hover{ background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.16); }
    .row .actions input{ width: 16px; height: 16px; }

    /* Inspector drawer */
    .drawer{
      position: fixed;
      top: 0; right: 0;
      height: 100%;
      width: min(520px, 100vw);
      background: #0b1020;
      border-left: 1px solid var(--border);
      box-shadow: var(--shadow);
      transform: translateX(110%);
      opacity: 0;
      transition: transform var(--dur-slow) var(--ease-settle), opacity var(--dur-med) var(--ease-settle);
      z-index: 80;
      display:flex;
      flex-direction: column;
      min-height: 0;
      pointer-events: none;
      will-change: transform, opacity;
    }
    .drawer.open{ transform: translateX(0%); opacity: 1; pointer-events: auto; }
    .drawer-h{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 10px;
    }
    .drawer-h .title{
      min-width:0;
    }
    .drawer-h .title h3{
      margin:0;
      font-size: 14px;
      font-weight: 780;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 360px;
    }
    .drawer-h .title .sub{
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 420px;
    }
    .xbtn{
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      cursor:pointer;
    }
    .xbtn:hover{ background: rgba(255,255,255,0.10); }

    .drawer-body{
      padding: 14px;
      display:flex;
      flex-direction: column;
      gap: 12px;
      overflow:auto;
      min-height: 0;
    }
    .preview{
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      background: rgba(255,255,255,0.04);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .preview video, .preview img{
      width: 100%;
      height: auto;
      display:block;
      background: rgba(0,0,0,0.25);
      max-height: 52vh;
      object-fit: contain;
    }

    .kv{
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      background: rgba(255,255,255,0.04);
      padding: 10px;
      display:grid;
      grid-template-columns: 120px 1fr;
      gap: 8px 10px;
      font-size: 12px;
      align-items:center;
    }
    .kv .k{ color: var(--muted); }
    .kv .v{ color: var(--text); overflow-wrap:anywhere; }

    .drawer-actions{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
    }

    /* Bottom selection bar */
    .selectbar{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 16px;
      z-index: 55;
      display:none;
      background: rgba(11,16,32,0.75);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 12px;
      box-shadow: var(--shadow);
      gap: 10px;
      align-items: stretch;
      flex-direction: column;
      max-width: min(980px, calc(100vw - 24px));
      width: min(980px, calc(100vw - 24px));
    }
    .selectbar.show{ display:flex; }
    .selectbar-row{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items:center;
    }
    .selectbar .count{ font-size: 12px; color: var(--muted); }
    .selectbar .sep{ width: 1px; height: 18px; background: var(--border); margin: 0 2px; }
    .selectbar .btn{ padding: 8px 11px; }
    .selectbar-panel{
      display:none;
      border-top: 1px solid var(--border);
      padding-top: 10px;
    }
    .selectbar-panel.open{
      display:block;
    }
    .selectbar-panel select{
      flex: 1 1 180px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      color: var(--text);
    }

    .mobile-fab{
      display:none;
    }

    /* Toasts */
    .toasts{
      position: fixed;
      top: 74px;
      right: 16px;
      z-index: 80;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }
    .toast{
      border: 1px solid var(--border);
      background: rgba(11,16,32,0.78);
      border-radius: 14px;
      padding: 10px 12px;
      min-width: 260px;
      max-width: 360px;
      box-shadow: var(--shadow);
      font-size: 12px;
      color: var(--text);
    }
    .toast .t{ font-weight: 700; margin-bottom: 3px; }
    .toast .m{ color: var(--muted); }
    .toast.good{ border-color: rgba(34,197,94,0.35); }
    .toast.warn{ border-color: rgba(245,158,11,0.35); }
    .toast.bad{ border-color: rgba(239,68,68,0.35); }

    /* Mobile */
    @media (max-width: 980px){
      .sidebar{ width: 320px; }
    }
    @media (max-width: 860px){
      body{ overflow:auto; }
      .main{ flex-direction: column; overflow:auto; }
      .sidebar{ display:block; width: 100%; }
      .content{ width: 100%; }
      .drawer{ width: 100vw; }
      .topbar-inner{
        flex-direction: row;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
      }
      .brand{
        min-width: 0;
        gap: 8px;
      }
      .toolbar{
        width: auto;
        flex: 1;
        justify-content: flex-end;
      }
      .topbar-controls{
        width: 100%;
        justify-content: flex-end;
      }
      .search{ max-width: 200px; min-width: 120px; }
      .btn{ padding: 7px 10px; font-size:11px; }
      .seg button{ padding: 7px 9px; font-size:11px; }
      .grid{ gap: 10px; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
      .asset .title{ font-size: 11px; }
      .section-h{ padding: 12px 12px 9px; }
      .sidebar{ border-radius: 0; }
      .drawer{ height: 85%; top: auto; bottom: 0; border-left: none; border-top: 1px solid var(--border); transform: translateY(110%); right:0; width:100%; }
      .drawer.open{ transform: translateY(0%); }
      .sidebar.sidebar-drawer{ top: 52px; height: calc(100% - 52px); border-radius: 0; }
      .mobile-only{ display:block; }
    }
    @media (max-width: 860px){
      .actions-panel{
        position: fixed;
        top: 58px;
        left: 12px;
        right: 12px;
      }
    }
    @media (prefers-reduced-motion: reduce){
      .asset,
      .drawer,
      .sidebar.sidebar-drawer,
      .backdrop,
      .brand-title{
        transition-duration: 1ms !important;
      }
    }
    .sidebar{
      background: rgba(11,16,32,0.92);
    }
    .sidebar .scroll{
      flex: 1;
      min-height: 0;
      overflow: auto;
    }
    .sidebar select,
    .sidebar option,
    .drawer select,
    .drawer option{
      color: var(--text);
      background: #0b1020;
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="topbar-inner">
        <div class="brand" id="brandToggle" title="LAN-only media-sync-api explorer">
          <div class="brand-text">
            <h1>
              <button id="brandTitle" type="button" aria-label="Toggle projects panel">
                <span class="brand-title is-primary">Cdaprod‚Äôs Explorer</span>
                <span class="brand-title is-secondary">Cdaprod‚Äôs Projects</span>
              </button>
            </h1>
            <div class="sub">media-sync-api</div>
          </div>
        </div>

        <div class="toolbar">
          <div class="topbar-controls">
            <div class="search" role="search">
              <span class="kbd">‚åòK</span>
              <input id="q" placeholder="Search filename, path‚Ä¶ (client-side filter)" autocomplete="off" />
            </div>
            <button id="actionsToggle" class="btn" type="button" aria-expanded="false">Actions ‚ñæ</button>
          </div>
          <div id="actionsPanel" class="actions-panel" role="region" aria-label="Explorer actions">
            <div class="seg" aria-label="View mode">
              <button id="viewGrid" class="active" type="button">Grid</button>
              <button id="viewList" type="button">List</button>
            </div>

            <div class="pillbar">
              <button id="refreshBtn" class="btn" type="button">‚Üª Refresh</button>
              <button id="pickUploadBtn" class="btn good" type="button">Ôºã Upload</button>
              <button id="sendResolveBtn" class="btn primary" type="button" disabled>‚á¢ Send to Resolve</button>
              <button id="deleteSelBtn" class="btn bad" type="button" disabled>üóë Delete Selected</button>
              <button id="clearSelBtn" class="btn" type="button" disabled>‚úï Clear</button>
            </div>

            <div class="tag-panel" id="batchTagPanel">
              <div class="small">Tag selected assets</div>
              <div class="tag-editor">
                <input id="batchTagInput" type="text" placeholder="e.g. highlight, vertical" />
                <button id="batchTagAdd" class="btn" type="button" disabled>Ôºã Tag</button>
                <button id="batchTagRemove" class="btn" type="button" disabled>‚àí Remove</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="main">
      <!-- Sidebar -->
      <aside id="sidebar" class="sidebar">
        <div class="section-h">
          <h2>Projects</h2>
          <div class="meta-line">
            <span id="projCount">‚Ä¶</span>
            <span class="kbd">Click</span>
          </div>
        </div>
        <div class="scroll">
          <div id="projects" class="chips"></div>

          <div class="section-h" style="border-top:1px solid var(--border);">
            <h2>Sources</h2>
            <div class="meta-line"><span class="kbd">/api/sources</span></div>
          </div>
          <div id="sources" class="sources"></div>

          <div class="section-h" style="border-top:1px solid var(--border);">
            <h2>Resolve</h2>
            <div class="meta-line"><span class="kbd">/api/resolve/open</span></div>
          </div>
          <div style="padding: 12px;">
            <div class="card">
              <strong>Mode</strong>
              <div class="small">Queue selected clips, then dispatch.</div>
              <div style="display:grid; grid-template-columns: 1fr; gap: 8px; margin-top: 10px;">
                <label style="font-size:12px; color:var(--muted);">Project mode</label>
                <select id="resolveProjectMode" style="padding:10px;border-radius:12px;border:1px solid var(--border);background:rgba(255,255,255,0.05);color:var(--text);">
                  <option value="current">Use current project</option>
                  <option value="__select__">Let host choose</option>
                  <option value="__new__">Create new project</option>
                </select>

                <label style="font-size:12px; color:var(--muted);">Project name</label>
                <input id="resolveProjectName" placeholder="P1-Public-Accountability"
                  style="padding:10px;border-radius:12px;border:1px solid var(--border);background:rgba(255,255,255,0.05);color:var(--text);" />

                <label style="font-size:12px; color:var(--muted);">New project name (if creating)</label>
                <input id="resolveNewName" placeholder="P3-Editorial"
                  style="padding:10px;border-radius:12px;border:1px solid var(--border);background:rgba(255,255,255,0.05);color:var(--text);" />

                <label style="font-size:12px; color:var(--muted);">Action</label>
                <select id="resolveMode" style="padding:10px;border-radius:12px;border:1px solid var(--border);background:rgba(255,255,255,0.05);color:var(--text);">
                  <option value="import">Import into media pool</option>
                  <option value="reveal_in_explorer">Reveal in Explorer/Finder</option>
                </select>

                <div class="small" id="resolveHint">Select clips to enable.</div>
              </div>
            </div>
          </div>

          <div class="section-h" style="border-top:1px solid var(--border);">
            <h2>Upload</h2>
            <div class="meta-line"><span class="kbd">/api/projects/*/upload</span></div>
          </div>
          <div style="padding: 12px;">
            <div class="card">
              <strong>Upload to active project</strong>
              <div class="small" id="uploadCaption">Pick a project first.</div>
              <div style="display:flex; gap:10px; align-items:center; margin-top: 10px; flex-wrap: wrap;">
                <input id="uploadFile" type="file" style="max-width: 100%; color: var(--muted);" />
                <button id="uploadBtn" class="btn good" type="button" disabled>Upload</button>
              </div>
              <div class="small" id="uploadStatus" style="margin-top:8px;"></div>
            </div>
          </div>
        </div>
      </aside>

      <!-- Content -->
      <section class="content">
        <div class="section-h">
          <h2 id="contentTitle">Media</h2>
          <div class="meta-line">
            <span id="mediaCount">0 items</span>
            <span>‚Ä¢</span>
            <span id="activePath" class="kbd">no project</span>
          </div>
        </div>

        <div class="scroll" id="mediaScroll">
          <div id="mediaGrid" class="grid"></div>
          <div id="mediaList" class="list" style="display:none;"></div>
        </div>
      </section>
    </div>

    <!-- Bottom selection bar -->
    <div id="selectBar" class="selectbar" role="status" aria-live="polite">
      <div class="selectbar-row">
        <div class="count"><span id="selCount">0</span> selected</div>
        <div class="sep"></div>
        <button id="selTagToggle" class="btn" type="button">üè∑ Tag Selected</button>
        <button id="selMoveToggle" class="btn" type="button">‚á¢ Move Selected</button>
        <button id="selCopyUrls" class="btn" type="button">‚ßâ Copy stream URLs</button>
        <button id="btnProgramMonitor" class="btn" type="button" hidden>‚ûï Add to Program Monitor</button>
      </div>

      <div class="selectbar-panel" id="selTagPanel">
        <div class="small">Add or remove tags for selected assets</div>
        <div class="tag-editor">
          <input id="selTagInput" type="text" placeholder="tag, another tag" />
          <button id="selTagAdd" class="btn" type="button">Ôºã Tag</button>
          <button id="selTagRemove" class="btn" type="button">‚àí Remove</button>
        </div>
      </div>

      <div class="selectbar-panel" id="selMovePanel">
        <div class="small">Move selected assets to a project</div>
        <div class="tag-editor">
          <select id="selMoveTarget" aria-label="Move target project"></select>
          <button id="selMoveSubmit" class="btn" type="button">‚á¢ Move</button>
        </div>
      </div>
    </div>

    <!-- Inspector drawer -->
    <aside id="drawer" class="drawer" aria-hidden="true">
      <div class="drawer-h">
        <div class="title">
          <h3 id="drawerTitle">‚Äî</h3>
          <div id="drawerSub" class="sub">‚Äî</div>
        </div>
        <button id="drawerClose" class="xbtn" type="button" aria-label="Close inspector">‚úï</button>
      </div>

      <div class="drawer-body">
        <div class="preview" id="drawerPreview"></div>

        <div class="drawer-actions">
          <button id="drawerPlay" class="btn" type="button">‚ñ∂ Play</button>
          <button id="drawerCopy" class="btn" type="button">‚ßâ Copy stream URL</button>
          <button id="drawerTagToggle" class="btn" type="button">üè∑ Tag</button>
          <button id="drawerSendOBS" class="btn" type="button">üì∫ Send to OBS</button>
          <button id="drawerDelete" class="btn bad" type="button">üóë Delete</button>
        </div>

        <div class="tag-panel drawer-tag-panel" id="drawerTagPanel">
          <div class="taglist" id="drawerTagList"></div>
          <div class="tag-editor">
            <input id="drawerTagInput" type="text" placeholder="Add or remove tag‚Ä¶" />
            <button id="drawerTagAdd" class="btn" type="button">Ôºã Tag</button>
            <button id="drawerTagRemove" class="btn" type="button">‚àí Remove</button>
          </div>
        </div>

        <div class="kv" id="drawerKV"></div>
      </div>
    </aside>

    <!-- Toasts -->
    <div class="toasts" id="toasts"></div>
    <div id="sidebarBackdrop" class="backdrop"></div>
    <div id="drawerBackdrop" class="backdrop" style="z-index:70;"></div>
  </div>

  <script src="js/obs-websocket.js"></script>
  <script type="module" src="js/program_monitor_handoff.js"></script>
  <script>
    // -------------------------
    // Config / state
    // -------------------------
    const API = ''; // same-origin; keep '' for container-served index.html
    const el = (id) => document.getElementById(id);

    const state = {
      projects: [],
      sources: [],
      activeProject: null,   // {name, source, ...}
      media: [],             // items from /media
      mediaScope: 'project', // project|all
      view: 'grid',          // grid|list
      q: '',
      selected: new Set(),   // relative_path
      focused: null,         // item
    };

    const ui = {
      sidebarOpen: false,
      inspectorOpen: false,
      dragActive: false,
    };

    const THUMB_CACHE_NAME = 'media-sync-thumb-cache-v1';
    const THUMB_MAX_WORKERS = 2;
    const thumbCache = new Map();
    const thumbPending = new Set();
    const thumbQueue = [];
    const thumbInFlight = new Set();
    let thumbActiveCount = 0;
    let thumbSweepTimer = null;
    let thumbQueueScheduled = false;
    let thumbObserver = null;

    // -------------------------
    // Utils
    // -------------------------
    function toast(type, title, message){
      const t = document.createElement('div');
      t.className = `toast ${type || ''}`;
      t.innerHTML = `<div class="t">${escapeHtml(title || 'Info')}</div><div class="m">${escapeHtml(message || '')}</div>`;
      el('toasts').appendChild(t);
      setTimeout(() => { t.style.opacity = '0'; t.style.transform = 'translateY(-4px)'; }, 2600);
      setTimeout(() => t.remove(), 3100);
    }

    function escapeHtml(s){
      return String(s ?? '')
        .replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')
        .replaceAll('"','&quot;').replaceAll("'","&#039;");
    }

    function thumbCacheKey(item){
      const project = item?.project_name || item?.project || '';
      const source = item?.project_source || item?.source || '';
      const rel = item?.relative_path || '';
      const sha = item?.sha256 || item?.hash || '';
      return [source, project, rel, sha].filter(Boolean).join('|');
    }

    function thumbCacheRequest(key){
      if (!key) return '';
      return `${window.location.origin}/__thumbs/${encodeURIComponent(key)}`;
    }

    function canUseCacheStorage(){
      return typeof window !== 'undefined' && 'caches' in window;
    }

    async function readThumbFromCache(key){
      if (!key) return null;
      if (!canUseCacheStorage()) return null;
      try{
        const cache = await caches.open(THUMB_CACHE_NAME);
        const response = await cache.match(thumbCacheRequest(key));
        if (!response) return null;
        const contentType = response.headers.get('content-type') || '';
        if (!contentType.startsWith('image/')) return null;
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      }catch(_){
        // ignore cache errors
      }
      return null;
    }

    async function writeThumbToCache(key, blob){
      if (!key || !blob || !canUseCacheStorage()) return;
      try{
        const cache = await caches.open(THUMB_CACHE_NAME);
        await cache.put(
          thumbCacheRequest(key),
          new Response(blob, {
            headers: {
              'Content-Type': blob.type || 'image/jpeg',
              'Cache-Control': 'public, max-age=31536000, immutable',
            },
          }),
        );
      }catch(_){
        // best-effort cache writes
      }
    }

    function encodePath(path){
      return String(path || '')
        .split('/')
        .map(segment => encodeURIComponent(segment))
        .join('/');
    }

    window.MediaExplorer = {
      getSelectedStreamUrlsInDomOrder,
    };

    function formatBytes(bytes){
      const n = Number(bytes || 0);
      if (!isFinite(n) || n <= 0) return '0 B';
      const units = ['B','KB','MB','GB','TB'];
      let i = 0;
      let v = n;
      while (v >= 1024 && i < units.length - 1){ v /= 1024; i++; }
      return `${v.toFixed(v >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
    }

    function parseTimestamp(value){
      if (!value) return 0;
      const ts = Date.parse(value);
      return Number.isNaN(ts) ? 0 : ts;
    }

    function filenameTimestamp(relativePath){
      if (!relativePath) return 0;
      const name = relativePath.split('/').pop() || relativePath;
      const dateTimeMatch = name.match(/(\d{4})-(\d{2})-(\d{2})[T_ -]?(\d{2})-(\d{2})-(\d{2})/);
      if (dateTimeMatch){
        const [, year, month, day, hour, minute, second] = dateTimeMatch;
        return Date.parse(`${year}-${month}-${day}T${hour}:${minute}:${second}`);
      }
      const dateMatch = name.match(/(\d{4})-(\d{2})-(\d{2})/);
      if (dateMatch){
        const [, year, month, day] = dateMatch;
        return Date.parse(`${year}-${month}-${day}T00:00:00`);
      }
      return 0;
    }

    function itemTimestamp(item){
      return Math.max(
        parseTimestamp(item.updated_at),
        parseTimestamp(item.updatedAt),
        parseTimestamp(item.created_at),
        parseTimestamp(item.createdAt),
        parseTimestamp(item.uploaded_at),
        parseTimestamp(item.uploadedAt),
        parseTimestamp(item.indexed_at),
        parseTimestamp(item.indexedAt),
        filenameTimestamp(item.relative_path),
      );
    }

    function sortMediaByRecent(items){
      return items.slice().sort((a, b) => {
        const delta = itemTimestamp(b) - itemTimestamp(a);
        if (delta !== 0) return delta;
        return String(b.relative_path || '').localeCompare(String(a.relative_path || ''));
      });
    }

    function projectLabel(item){
      const name = item.project_name || item.project || '';
      const source = item.project_source || item.source || '';
      if (!name) return '';
      return source ? `${name} (${source})` : name;
    }

    function toAbsoluteUrl(path){
      if (!path) return '';
      if (path.startsWith('http://') || path.startsWith('https://')) {
        return path;
      }
      return new URL(path, window.location.origin).toString();
    }

    function ensureObsWebsocketLoaded(){
      if (typeof OBSWebSocket !== 'undefined') return Promise.resolve();
      return new Promise((resolve, reject) => {
        const existing = document.querySelector('script[data-obs-websocket]');
        if (existing){
          existing.addEventListener('load', () => resolve(), { once: true });
          existing.addEventListener('error', () => reject(new Error('OBSWebSocket failed to load')), { once: true });
          return;
        }
        const script = document.createElement('script');
        script.src = 'js/obs-websocket.js';
        script.async = true;
        script.dataset.obsWebsocket = 'true';
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('OBSWebSocket failed to load'));
        document.head.appendChild(script);
      });
    }

    function normalizeObsName(value){
      return String(value || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '');
    }

    function buildObsPlayerUrl(assetUrl, { fit = 'cover', muted = false } = {}){
      if (!assetUrl) return '';
      const src = encodeURIComponent(assetUrl);
      const params = new URLSearchParams({
        src,
        fit,
        muted: muted ? '1' : '0',
      });
      return `${window.location.origin}/player.html?${params.toString()}`;
    }

    async function resolveObsInputName(obs, desiredName){
      const name = String(desiredName || '').trim();
      if (!name) throw new Error('OBS input name is required');
      const response = await obs.call('GetInputList');
      const inputs = Array.isArray(response?.inputs) ? response.inputs : [];
      const normalized = normalizeObsName(name);
      let match = inputs.find((entry) => entry.inputName === name);
      if (!match && normalized){
        match = inputs.find((entry) => normalizeObsName(entry.inputName) === normalized);
      }
      if (!match && normalized){
        match = inputs.find((entry) => normalizeObsName(entry.inputName).startsWith(normalized));
      }
      if (!match && normalized){
        match = inputs.find((entry) => normalized.startsWith(normalizeObsName(entry.inputName)));
      }
      if (match?.inputName){
        return match.inputName;
      }
      try{
        const sceneItems = await obs.call('GetSceneItemList', { sceneName: name });
        const items = Array.isArray(sceneItems?.sceneItems) ? sceneItems.sceneItems : [];
        const preferred = items.find((item) => ['browser_source','ffmpeg_source','vlc_source'].includes(item.inputKind));
        if (preferred?.sourceName){
          return preferred.sourceName;
        }
        const fallback = items.find((item) => item.sourceName);
        if (fallback?.sourceName){
          return fallback.sourceName;
        }
      }catch(_){
        // ignore scene lookup failures
      }
      const names = inputs.map((entry) => entry.inputName).filter(Boolean);
      const hint = names.length ? names.join(', ') : 'none';
      throw new Error(`OBS input "${name}" not found. Available inputs: ${hint}`);
    }

    async function resolveObsSceneName(obs, desiredName){
      const name = String(desiredName || '').trim();
      if (!name) throw new Error('OBS scene name is required');
      const response = await obs.call('GetSceneList');
      const scenes = Array.isArray(response?.scenes) ? response.scenes : [];
      const normalized = normalizeObsName(name);
      let match = scenes.find((scene) => scene.sceneName === name);
      if (!match && normalized){
        match = scenes.find((scene) => normalizeObsName(scene.sceneName) === normalized);
      }
      if (!match && normalized){
        match = scenes.find((scene) => normalizeObsName(scene.sceneName).startsWith(normalized));
      }
      if (!match && normalized){
        match = scenes.find((scene) => normalized.startsWith(normalizeObsName(scene.sceneName)));
      }
      if (match?.sceneName){
        return match.sceneName;
      }
      const names = scenes.map((scene) => scene.sceneName).filter(Boolean);
      const hint = names.length ? names.join(', ') : 'none';
      throw new Error(`OBS scene "${name}" not found. Available scenes: ${hint}`);
    }

    async function findObsSceneItemId(obs, sceneName, inputName){
      const response = await obs.call('GetSceneItemList', { sceneName });
      const items = Array.isArray(response?.sceneItems) ? response.sceneItems : [];
      const match = items.find((item) => item.sourceName === inputName);
      if (!match?.sceneItemId){
        throw new Error(`OBS input "${inputName}" is not present in scene "${sceneName}"`);
      }
      return match.sceneItemId;
    }

    async function applyObsSceneItemTransform(obs, sceneName, sceneItemId, fit){
      const videoSettings = await obs.call('GetVideoSettings');
      const baseWidth = Number(videoSettings?.baseWidth || 0);
      const baseHeight = Number(videoSettings?.baseHeight || 0);
      const currentItem = await obs.call('GetSceneItemTransform', { sceneName, sceneItemId });
      const itemTransform = currentItem?.sceneItemTransform || {};
      const sourceWidth = Number(itemTransform.sourceWidth || baseWidth || 1080);
      const sourceHeight = Number(itemTransform.sourceHeight || baseHeight || 1920);
      if (!baseWidth || !baseHeight || !sourceWidth || !sourceHeight) return;
      const scale = fit === 'contain'
        ? Math.min(baseWidth / sourceWidth, baseHeight / sourceHeight)
        : Math.max(baseWidth / sourceWidth, baseHeight / sourceHeight);
      const positionX = (baseWidth - sourceWidth * scale) / 2;
      const positionY = (baseHeight - sourceHeight * scale) / 2;
      await obs.call('SetSceneItemTransform', {
        sceneName,
        sceneItemId,
        sceneItemTransform: {
          positionX,
          positionY,
          scaleX: scale,
          scaleY: scale,
          rotation: 0,
          alignment: 0,
        },
      });
    }

    async function warnIfObsInputKind(obs, inputName){
      try{
        const response = await obs.call('GetInputList');
        const inputs = Array.isArray(response?.inputs) ? response.inputs : [];
        const match = inputs.find((entry) => entry.inputName === inputName);
        if (match && match.inputKind !== 'browser_source'){
          toast('warn', 'OBS', `Input "${inputName}" is "${match.inputKind}". Use a Browser Source for best results.`);
        }
      }catch(_){
        // ignore input kind lookup failures
      }
    }

    async function warnIfObsInputShared(obs, inputName, sceneName){
      try{
        const response = await obs.call('GetSceneList');
        const scenes = Array.isArray(response?.scenes) ? response.scenes : [];
        const scenesWithInput = [];
        for (const scene of scenes){
          if (scene.sceneName === sceneName) continue;
          const items = await obs.call('GetSceneItemList', { sceneName: scene.sceneName });
          const list = Array.isArray(items?.sceneItems) ? items.sceneItems : [];
          if (list.some((item) => item.sourceName === inputName)){
            scenesWithInput.push(scene.sceneName);
          }
        }
        if (scenesWithInput.length){
          toast('warn', 'OBS', `Input "${inputName}" is shared with scenes: ${scenesWithInput.join(', ')}. Use a dedicated Browser Source for ASSET_MEDIA.`);
        }
      }catch(_){
        // ignore sharing check failures
      }
    }

    async function obsReplaceAssetMediaUrl({
      obsHost = '192.168.0.187',
      obsPort = 4455,
      sceneName = 'ASSET_MEDIA',
      inputName = 'ASSET_MEDIA',
      obsPassword = '123456',
      fit = 'cover',
      muted = false,
      assetUrl,
    }){
      if (!assetUrl) throw new Error('assetUrl is required');
      await ensureObsWebsocketLoaded();
      if (typeof OBSWebSocket === 'undefined'){
        throw new Error('OBSWebSocket is not available. Load obs-websocket-js v5 before this script.');
      }

      const obs = new OBSWebSocket();
      await obs.connect(`ws://${obsHost}:${obsPort}`, obsPassword);

      const resolvedSceneName = await resolveObsSceneName(obs, sceneName);
      const resolvedInputName = await resolveObsInputName(obs, inputName);
      const playerUrl = buildObsPlayerUrl(assetUrl, { fit, muted });
      const videoSettings = await obs.call('GetVideoSettings');
      const baseWidth = Number(videoSettings?.baseWidth || 1080);
      const baseHeight = Number(videoSettings?.baseHeight || 1920);
      await obs.call('SetInputSettings', {
        inputName: resolvedInputName,
        inputSettings: {
          url: playerUrl,
          width: baseWidth,
          height: baseHeight,
          fps: 60,
          shutdown: false,
          restart_when_active: true,
        },
        overlay: false,
      });

      try{
        await obs.call('PressInputPropertiesButton', {
          inputName: resolvedInputName,
          propertyName: 'refreshnocache',
        });
      }catch(_){
        // Best-effort refresh for Browser Sources.
      }

      const sceneItemId = await findObsSceneItemId(obs, resolvedSceneName, resolvedInputName);
      await applyObsSceneItemTransform(obs, resolvedSceneName, sceneItemId, fit);
      await warnIfObsInputKind(obs, resolvedInputName);
      await warnIfObsInputShared(obs, resolvedInputName, resolvedSceneName);

      await obs.disconnect();
    }

    function buildThumbFallback(label){
      const safeLabel = String(label || 'MEDIA').replace(/[^a-z0-9 ]/gi, '').slice(0, 12) || 'MEDIA';
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="640" height="360" viewBox="0 0 640 360">
          <defs>
            <linearGradient id="bg" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stop-color="#2a2d3a"/>
              <stop offset="100%" stop-color="#1d2030"/>
            </linearGradient>
          </defs>
          <rect width="640" height="360" rx="28" fill="url(#bg)"/>
          <rect x="24" y="24" width="592" height="312" rx="22" fill="rgba(255,255,255,0.06)"/>
          <text x="50%" y="52%" dominant-baseline="middle" text-anchor="middle" fill="#b7bcc8"
            font-family="Inter, system-ui, sans-serif" font-size="48" font-weight="600" letter-spacing="2">
            ${safeLabel.toUpperCase()}
          </text>
        </svg>
      `;
      return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
    }

    async function copyTextWithFallback(text){
      if (!text) return false;
      if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function'){
        try{
          await navigator.clipboard.writeText(text);
          return true;
        }catch(e){
          // fallback continues below
        }
      }
      const temp = document.createElement('textarea');
      temp.value = text;
      temp.setAttribute('readonly','');
      temp.style.position = 'fixed';
      temp.style.top = '-1000px';
      temp.style.left = '-1000px';
      document.body.appendChild(temp);
      temp.focus();
      temp.select();
      let ok = false;
      try{
        ok = document.execCommand('copy');
      }catch(e){
        ok = false;
      }
      temp.remove();
      if (ok) return true;
      if (typeof window.prompt === 'function'){
        window.prompt('Copy to clipboard', text);
        return true;
      }
      return false;
    }

    function dragPayload(item){
      const paths = state.selected.has(item.relative_path)
        ? Array.from(state.selected)
        : [item.relative_path];
      return JSON.stringify({ paths });
    }

    function attachDragData(event, item){
      if (!item || !event.dataTransfer) return;
      event.dataTransfer.setData('application/x-media-sync', dragPayload(item));
      const downloadUrl = toAbsoluteUrl(item.download_url || item.stream_url || '');
      if (downloadUrl){
        const filename = item.relative_path?.split('/').pop() || 'media';
        event.dataTransfer.setData('DownloadURL', `application/octet-stream:${filename}:${downloadUrl}`);
        event.dataTransfer.setData('text/uri-list', downloadUrl);
      }
      event.dataTransfer.effectAllowed = 'move';
    }

    function guessKind(item){
      // Prefer backend-provided kind/mime if present.
      const k = (item.kind || item.type || '').toLowerCase();
      if (k) return k;
      const p = (item.relative_path || '').toLowerCase();
      if (/\.(mp4|mov|mkv|webm|m4v)$/.test(p)) return 'video';
      if (/\.(jpg|jpeg|png|gif|webp|heic)$/.test(p)) return 'image';
      if (/\.(mp3|wav|m4a|aac|flac)$/.test(p)) return 'audio';
      return 'document';
    }

    function kindBadgeClass(kind){
      if (kind === 'video') return 'kind-video';
      if (kind === 'image') return 'kind-image';
      if (kind === 'audio') return 'kind-audio';
      return 'kind-doc';
    }

    function isMobile(){
      return window.matchMedia('(max-width: 860px)').matches;
    }

    function mediaQuery(){
      const p = state.activeProject;
      if (!p) return '';
      return p.source ? `?source=${encodeURIComponent(p.source)}` : '';
    }

    function parseTagInput(value){
      return String(value || '')
        .split(',')
        .map(tag => tag.trim())
        .filter(tag => tag.length > 0);
    }

    function updateTopCounts(){
      el('projCount').textContent = `${state.projects.length} total`;
      const name = state.activeProject?.name || (state.mediaScope === 'all' ? 'all projects' : 'no project');
      el('activePath').textContent = name;
      el('contentTitle').textContent = state.activeProject
        ? `Media ‚Äî ${name}`
        : (state.mediaScope === 'all' ? 'Media ‚Äî All Projects' : 'Media');
      el('mediaCount').textContent = `${filteredMedia().length} items`;
    }

    function filteredMedia(){
      const q = state.q.trim().toLowerCase();
      if (!q) return state.media.slice();
      return state.media.filter(it => (it.relative_path || '').toLowerCase().includes(q));
    }

    function getVisibleMediaContainer(){
      const grid = el('mediaGrid');
      const list = el('mediaList');
      const gridVisible = grid && window.getComputedStyle(grid).display !== 'none';
      if (gridVisible) return { container: grid, selector: '.asset.is-selected' };
      return { container: list, selector: '.row.is-selected' };
    }

    function getSelectedStreamUrlsInDomOrder(){
      const { container, selector } = getVisibleMediaContainer();
      if (!container) return [];
      const cards = Array.from(container.querySelectorAll(selector));
      return cards.map((card) => {
        const direct = card.dataset.streamUrl || card.dataset.url || '';
        if (direct){
          return toAbsoluteUrl(direct);
        }
        const project = card.dataset.project || state.activeProject?.name || '';
        const rel = card.dataset.relative || '';
        const source = card.dataset.source || 'primary';
        if (project && rel){
          const suffix = source && source !== 'primary' ? `?source=${encodeURIComponent(source)}` : '';
          return toAbsoluteUrl(`/media/${encodeURIComponent(project)}/${encodePath(rel)}${suffix}`);
        }
        const item = state.media.find((entry) => entry.relative_path === rel);
        if (item?.stream_url){
          return toAbsoluteUrl(item.stream_url);
        }
        return '';
      }).filter(Boolean);
    }

    function updateSelectionUI(){
      const count = state.selected.size;
      el('selCount').textContent = String(count);
      const show = count > 0;
      el('selectBar').classList.toggle('show', show);

      // enable/disable action buttons
      el('sendResolveBtn').disabled = !show || !state.activeProject;
      el('clearSelBtn').disabled = !show;
      el('deleteSelBtn').disabled = !show || !state.activeProject;
      el('selTagToggle').disabled = !show || !state.activeProject;
      el('selMoveToggle').disabled = !show || !state.activeProject;
      el('selCopyUrls').disabled = !show || !state.activeProject;
      el('btnProgramMonitor').disabled = !show || !state.activeProject;
      el('btnProgramMonitor').hidden = !show;

      updateTagButtons();
      if (!show){
        setSelectPanel('selTagPanel', false);
        setSelectPanel('selMovePanel', false);
      }
      el('drawerDelete').disabled = !state.focused;
      const obsUrl = state.focused?.stream_url || state.focused?.streamUrl || '';
      el('drawerSendOBS').disabled = !state.focused || !obsUrl;
    }

    function updateTagButtons(){
      const hasSelection = state.selected.size > 0 && state.activeProject;
      const hasFocused = !!state.focused;
      const batchInput = el('batchTagInput');
      const drawerInput = el('drawerTagInput');
      const selInput = el('selTagInput');
      const batchHasValue = !!parseTagInput(batchInput?.value).length;
      const drawerHasValue = !!parseTagInput(drawerInput?.value).length;
      const selHasValue = !!parseTagInput(selInput?.value).length;

      el('batchTagAdd').disabled = !hasSelection || !batchHasValue;
      el('batchTagRemove').disabled = !hasSelection || !batchHasValue;
      el('drawerTagAdd').disabled = !hasFocused || !drawerHasValue;
      el('drawerTagRemove').disabled = !hasFocused || !drawerHasValue;
      el('drawerTagToggle').disabled = !hasFocused;
      el('selTagAdd').disabled = !hasSelection || !selHasValue;
      el('selTagRemove').disabled = !hasSelection || !selHasValue;
    }

    function setSelectPanel(panelId, open){
      const panel = el(panelId);
      if (!panel) return;
      panel.classList.toggle('open', open);
    }

    function toggleSelectPanel(panelId){
      const panel = el(panelId);
      if (!panel) return;
      const willOpen = !panel.classList.contains('open');
      setSelectPanel('selTagPanel', false);
      setSelectPanel('selMovePanel', false);
      setSelectPanel(panelId, willOpen);
      if (willOpen){
        const input = panel.querySelector('input, select');
        input?.focus?.();
      }
    }

    async function fetchMetadata(item){
      if (!item?.metadata_path) return null;
      const p = state.activeProject;
      if (!p) return null;
      const url = `${API}/media/${encodeURIComponent(p.name)}/${encodePath(item.metadata_path)}${mediaQuery()}`;
      try{
        const r = await fetch(url);
        if (!r.ok) return null;
        return await r.json();
      }catch{
        return null;
      }
    }

    function renderTagList(container, tags, onRemove){
      container.innerHTML = '';
      const list = Array.isArray(tags) ? tags : [];
      if (!list.length){
        const empty = document.createElement('span');
        empty.className = 'tag';
        empty.textContent = 'No tags';
        container.appendChild(empty);
        return;
      }
      list.forEach((tag) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tag tag-button';
        const label = document.createElement('span');
        label.textContent = tag;
        const remove = document.createElement('span');
        remove.textContent = '√ó';
        btn.appendChild(label);
        btn.appendChild(remove);
        btn.addEventListener('click', () => onRemove(tag));
        container.appendChild(btn);
      });
    }

    async function loadDrawerTags(item){
      const tagList = el('drawerTagList');
      if (!tagList) return;
      if (!item){
        tagList.innerHTML = '';
        return;
      }
      tagList.innerHTML = '<span class="tag">Loading‚Ä¶</span>';
      const metadata = await fetchMetadata(item);
      const manualTags = metadata?.tags?.manual || [];
      renderTagList(tagList, manualTags, (tag) => applyTagsToPaths([item.relative_path], [], [tag]));
    }

    async function applyTagsToPaths(paths, addTags, removeTags){
      const p = state.activeProject;
      if (!p){
        toast('warn','Tags','Select a project first');
        return;
      }
      if (!paths.length){
        toast('warn','Tags','Select one or more clips');
        return;
      }
      const add = (addTags || []).length ? addTags : [];
      const remove = (removeTags || []).length ? removeTags : [];
      if (!add.length && !remove.length){
        toast('warn','Tags','Enter a tag name');
        return;
      }
      try{
        const r = await fetch(`${API}/api/projects/${encodeURIComponent(p.name)}/media/tags${mediaQuery()}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            relative_paths: paths,
            add_tags: add,
            remove_tags: remove,
          }),
        });
        const payload = await r.json().catch(() => ({}));
        if (!r.ok) throw new Error(payload.detail || payload.message || 'Tag update failed');
        toast('good','Tags', `Updated ${payload.updated?.length || 0} assets`);
        if (state.focused){
          await loadDrawerTags(state.focused);
        }
      }catch(e){
        toast('bad','Tags', e.message);
      }
    }

    function renderMoveTargets(){
      const select = el('selMoveTarget');
      if (!select) return;
      const active = state.activeProject;
      const options = state.projects.filter((proj) => {
        if (!active) return true;
        return proj.name !== active.name || proj.source !== active.source;
      });

      select.innerHTML = '';
      if (!options.length){
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No other projects available';
        select.appendChild(opt);
        select.disabled = true;
        return;
      }
      select.disabled = false;
      options.forEach((proj) => {
        const opt = document.createElement('option');
        opt.value = JSON.stringify({ name: proj.name, source: proj.source || null });
        opt.textContent = proj.source ? `${proj.name} (${proj.source})` : proj.name;
        select.appendChild(opt);
      });
    }

    async function copySelectedUrls(){
      if (!state.selected.size){
        toast('warn','Copy','Select one or more clips');
        return;
      }
      const urls = getSelectedStreamUrlsInDomOrder();
      if (!urls.length){
        toast('warn','Copy','No stream URLs found');
        return;
      }
      const text = urls.join('\n');
      const ok = await copyTextWithFallback(text);
      if (ok){
        toast('good','Copied', `Copied ${urls.length} URL(s)`);
      }else{
        toast('warn','Clipboard', 'Copy failed ‚Äî please copy manually.');
      }
    }

    async function sendSelectedToProgramMonitor(){
      const btn = el('btnProgramMonitor');
      const prev = btn?.textContent || '‚ûï Add to Program Monitor';
      if (!window.ProgramMonitorHandoff?.sendSelectedToProgramMonitor){
        alert('Program Monitor handoff is unavailable. Reload the page.');
        return;
      }
      try{
        if (btn){
          btn.textContent = 'Sending‚Ä¶';
          btn.disabled = true;
        }
        await window.ProgramMonitorHandoff.sendSelectedToProgramMonitor();
        if (btn){
          btn.textContent = 'Sent ‚úì';
          setTimeout(() => {
            btn.textContent = prev;
          }, 900);
        }
      }catch(e){
        alert(e?.message || String(e));
        if (btn) btn.textContent = prev;
      }finally{
        updateSelectionUI();
      }
    }

    function setSidebarOpen(open){
      const sb = el('sidebar');
      if (!sb) return;
      const drawerMode = sb.classList.contains('sidebar-drawer');
      if (!drawerMode){
        sb.style.pointerEvents = 'auto';
        ui.sidebarOpen = false;
        el('brandToggle')?.classList.remove('projects-open');
        el('sidebarBackdrop')?.classList.remove('show');
        return;
      }
      ui.sidebarOpen = open;
      sb.classList.toggle('is-open', open);
      el('brandToggle')?.classList.toggle('projects-open', open);
      el('sidebarBackdrop')?.classList.toggle('show', open);
    }

    function setInspectorOpen(open){
      const d = el('drawer');
      if (!d) return;
      ui.inspectorOpen = open;
      if (open){
        d.classList.add('open');
        d.setAttribute('aria-hidden', 'false');
      }else{
        d.classList.remove('open');
        d.setAttribute('aria-hidden', 'true');
      }
      el('drawerBackdrop')?.classList.toggle('show', open);
      if (!open){
        el('drawerTagPanel')?.classList.remove('open');
      }
    }

    function setDragActive(active){
      ui.dragActive = active;
      const content = document.querySelector('.content');
      if (content){
        content.classList.toggle('drag-active', active);
      }
    }

    function syncSidebarMode(){
      const sb = el('sidebar');
      if (!sb) return;
      const mobile = isMobile();
      sb.classList.toggle('sidebar-drawer', mobile);
      if (!mobile){
        sb.classList.remove('is-open');
        el('sidebarBackdrop')?.classList.remove('show');
        ui.sidebarOpen = false;
        sb.style.transform = '';
        sb.style.pointerEvents = 'auto';
      }else{
        setSidebarOpen(false);
      }
    }

    function setView(view){
      state.view = view;
      el('viewGrid').classList.toggle('active', view === 'grid');
      el('viewList').classList.toggle('active', view === 'list');
      el('mediaGrid').style.display = (view === 'grid') ? '' : 'none';
      el('mediaList').style.display = (view === 'list') ? '' : 'none';
      renderMedia();
    }

    function ensureThumbObserver(){
      if (thumbObserver) return thumbObserver;
      thumbObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) return;
          thumbObserver.unobserve(entry.target);
          const rel = entry.target.dataset.rel;
          const url = entry.target.dataset.url;
          const duration = Number(entry.target.dataset.duration) || 0;
          const itemKind = entry.target.dataset.kind;
          const cacheKey = entry.target.dataset.thumbKey || rel;
          const state = entry.target.dataset.state || 'idle';
          const attempts = Number(entry.target.dataset.attempts || 0);
          if (itemKind !== 'video') return;
          if (state === 'loaded' || attempts >= 3) return;
          requestIdle(() => enqueueThumbWork(rel, url, duration, entry.target, cacheKey));
        });
      }, { root: el('mediaScroll'), rootMargin: '200px 0px', threshold: 0.1 });
      return thumbObserver;
    }

    function requestIdle(fn){
      if (window.requestIdleCallback){
        window.requestIdleCallback(fn, { timeout: 1200 });
      }else{
        setTimeout(fn, 150);
      }
    }

    function setThumbImage(target, dataUrl){
      if (!target) return;
      const img = target.querySelector('img') || null;
      if (img){
        img.onerror = null;
        img.src = dataUrl;
        return;
      }
      const fallbackImg = document.createElement('img');
      fallbackImg.alt = 'Video thumbnail';
      fallbackImg.loading = 'lazy';
      fallbackImg.src = dataUrl;
      target.prepend(fallbackImg);
    }

    function scheduleThumbQueue(){
      if (thumbQueueScheduled) return;
      thumbQueueScheduled = true;
      requestIdle(() => {
        thumbQueueScheduled = false;
        processThumbQueue();
      });
    }

    function isThumbTargetVisible(target){
      if (!target || !target.getBoundingClientRect) return false;
      if (target.getClientRects().length === 0) return false;
      const style = window.getComputedStyle(target);
      if (style.display === 'none' || style.visibility === 'hidden') return false;
      if (target.offsetParent === null && style.position !== 'fixed') return false;
      const root = el('mediaScroll');
      const rect = target.getBoundingClientRect();
      const rootRect = root?.getBoundingClientRect?.() || { top: 0, bottom: window.innerHeight };
      return rect.bottom >= rootRect.top - 200 && rect.top <= rootRect.bottom + 200;
    }

    function enqueueThumbWork(relPath, url, durationHint, target, cacheKey){
      const key = cacheKey || relPath;
      if (!key || !url || !target) return;
      const state = target.dataset.state || 'idle';
      const attempts = Number(target.dataset.attempts || 0);
      if (state === 'loaded' || state === 'loading' || attempts >= 3) return;
      if (thumbInFlight.has(key)) return;
      thumbQueue.push({ relPath, url, durationHint, target, key });
      thumbInFlight.add(key);
      scheduleThumbQueue();
    }

    function processThumbQueue(){
      while (thumbActiveCount < THUMB_MAX_WORKERS && thumbQueue.length){
        const job = thumbQueue.shift();
        if (!job?.target || !job.target.isConnected){
          thumbInFlight.delete(job?.key);
          continue;
        }
        if (!isThumbTargetVisible(job.target)){
          thumbInFlight.delete(job.key);
          continue;
        }
        thumbActiveCount += 1;
        job.target.dataset.state = 'loading';
        generateThumb(job.relPath, job.url, job.durationHint, job.target, job.key)
          .finally(() => {
            thumbActiveCount = Math.max(0, thumbActiveCount - 1);
            thumbInFlight.delete(job.key);
            processThumbQueue();
          });
      }
    }

    function scheduleThumbSweep(){
      if (thumbSweepTimer) clearTimeout(thumbSweepTimer);
      thumbSweepTimer = setTimeout(() => {
        thumbSweepTimer = null;
        const targets = Array.from(document.querySelectorAll('[data-kind="video"][data-url]'));
        targets.forEach((target) => {
          if (!isThumbTargetVisible(target)) return;
          const rel = target.dataset.rel;
          const url = target.dataset.url;
          const duration = Number(target.dataset.duration || 0);
          const key = target.dataset.thumbKey || rel;
          enqueueThumbWork(rel, url, duration, target, key);
        });
      }, 120);
    }

    async function generateThumb(relPath, url, durationHint, target, cacheKey){
      const key = cacheKey || relPath;
      if (!url || !key) return;
      const attempts = Number(target?.dataset?.attempts || 0);
      if (thumbCache.has(key)){
        setThumbImage(target, thumbCache.get(key));
        target.dataset.state = 'loaded';
        return;
      }
      try{
        const stored = await readThumbFromCache(key);
        if (stored){
          thumbCache.set(key, stored);
          setThumbImage(target, stored);
          target.dataset.state = 'loaded';
          return;
        }
        const blob = await extractVideoFrame(url, durationHint);
        const objectUrl = URL.createObjectURL(blob);
        thumbCache.set(key, objectUrl);
        setThumbImage(target, objectUrl);
        target.dataset.state = 'loaded';
        void writeThumbToCache(key, blob);
      }catch{
        if (target){
          target.innerHTML = '<div class="fallback">VIDEO</div>';
          target.dataset.state = 'idle';
          target.dataset.attempts = String(attempts + 1);
          if (attempts + 1 < 3){
            setTimeout(() => {
              ensureThumbObserver().observe(target);
              scheduleThumbSweep();
            }, 800);
          }else{
            target.dataset.state = 'error';
          }
        }
      }
    }

    function extractVideoFrame(url, durationHint){
      return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.preload = 'metadata';
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = 'anonymous';
        const withTimeHint = url.includes('#') ? url : `${url}#t=0.1`;
        video.src = withTimeHint;

        const timeout = setTimeout(() => {
          cleanup();
          reject(new Error('thumb-timeout'));
        }, 6000);

        function cleanup(){
          clearTimeout(timeout);
          video.src = '';
        }

        let settled = false;

        function capture(){
          if (settled) return;
          settled = true;
          try{
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 360;
            const ctx = canvas.getContext('2d');
            if (!ctx) throw new Error('thumb-canvas');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            canvas.toBlob((blob) => {
              cleanup();
              if (!blob) return reject(new Error('thumb-blob'));
              resolve(blob);
            }, 'image/jpeg', 0.82);
          }catch(err){
            cleanup();
            reject(err);
          }
        }

        let targetTime = Math.min(Math.max(durationHint || 0.5, 0.3), 1.5);
        video.addEventListener('loadedmetadata', () => {
          targetTime = Number.isFinite(video.duration) && video.duration > 0
            ? Math.min(Math.max(video.duration * 0.05, 0.3), 2.0)
            : Math.min(Math.max(durationHint || 0.5, 0.3), 1.5);
          video.currentTime = targetTime;
        }, { once:true });

        video.addEventListener('seeked', capture, { once:true });
        video.addEventListener('loadeddata', () => {
          if (settled) return;
          if (video.readyState >= 2 && (video.currentTime >= targetTime || video.currentTime > 0)){
            capture();
          }
        }, { once:true });
        video.addEventListener('timeupdate', () => {
          if (settled) return;
          if (video.readyState >= 2 && (video.currentTime >= targetTime || video.currentTime > 0)){
            capture();
          }
        }, { once:true });
        video.addEventListener('error', () => { cleanup(); reject(new Error('thumb-error')); }, { once:true });
      });
    }

    async function primeThumbFromCache(target){
      if (!target) return false;
      const key = target.dataset.thumbKey || target.dataset.rel;
      if (!key) return false;
      if (thumbCache.has(key)){
        setThumbImage(target, thumbCache.get(key));
        target.dataset.state = 'loaded';
        return true;
      }
      if (thumbPending.has(key)) return false;
      thumbPending.add(key);
      try{
        const stored = await readThumbFromCache(key);
        if (stored){
          thumbCache.set(key, stored);
          setThumbImage(target, stored);
          target.dataset.state = 'loaded';
          return true;
        }
      }finally{
        thumbPending.delete(key);
      }
      target.dataset.state = target.dataset.state || 'idle';
      target.dataset.attempts = target.dataset.attempts || '0';
      scheduleThumbSweep();
      return false;
    }

    // -------------------------
    // Fetchers
    // -------------------------
    async function loadSources(){
      try{
        const r = await fetch(`${API}/api/sources`);
        if (!r.ok) throw new Error('Failed to list sources');
        state.sources = await r.json();
        renderSources();
      }catch(e){
        toast('bad','Sources', e.message);
      }
    }

    async function loadProjects(){
      try{
        const r = await fetch(`${API}/api/projects`);
        if (!r.ok) throw new Error('Failed to list projects');
        state.projects = await r.json();
        renderProjects();
        updateTopCounts();
        renderMoveTargets();
      }catch(e){
        toast('bad','Projects', e.message);
      }
    }

    async function loadMedia(){
      if (!state.activeProject){
        state.media = [];
        state.mediaScope = 'project';
        renderMedia();
        updateTopCounts();
        return;
      }
      const name = state.activeProject.name;
      try{
        const r = await fetch(`${API}/api/projects/${encodeURIComponent(name)}/media${mediaQuery()}`);
        if (!r.ok) throw new Error('Failed to load media list');
        const payload = await r.json();
        state.mediaScope = 'project';
        const items = Array.isArray(payload.media) ? payload.media : [];
        state.media = sortMediaByRecent(items);
        // clear selection if selected files disappeared
        const existing = new Set(state.media.map(m => m.relative_path));
        for (const s of Array.from(state.selected)){
          if (!existing.has(s)) state.selected.delete(s);
        }
        renderMedia();
        updateTopCounts();
        updateSelectionUI();
      }catch(e){
        toast('bad','Media', e.message);
      }
    }

    async function loadAllMedia(){
      state.mediaScope = 'all';
      state.selected.clear();
      state.focused = null;
      const items = [];
      if (!state.projects.length){
        state.media = [];
        renderMedia();
        updateTopCounts();
        updateSelectionUI();
        return;
      }
      for (const project of state.projects){
        const query = project.source ? `?source=${encodeURIComponent(project.source)}` : '';
        try{
          const r = await fetch(`${API}/api/projects/${encodeURIComponent(project.name)}/media${query}`);
          if (!r.ok) throw new Error('Failed to load media list');
          const payload = await r.json();
          const media = Array.isArray(payload.media) ? payload.media : [];
          media.forEach((item) => {
            items.push({
              ...item,
              project_name: project.name,
              project_source: project.source || null,
            });
          });
        }catch(e){
          toast('warn','Media', `Skipped ${project.name}: ${e.message}`);
        }
      }
      state.media = sortMediaByRecent(items);
      renderMedia();
      updateTopCounts();
      updateSelectionUI();
    }

    // -------------------------
    // Renderers
    // -------------------------
    function renderSources(){
      const root = el('sources');
      root.innerHTML = '';
      if (!state.sources.length){
        root.innerHTML = `<div class="card"><strong>No sources</strong><div class="small">Only the primary mount is available.</div></div>`;
        return;
      }
      for (const s of state.sources){
        const card = document.createElement('div');
        card.className = 'card';
        const reach = s.accessible ? 'reachable' : 'unreachable';
        const enabled = s.enabled ? 'enabled' : 'disabled';
        card.innerHTML =
          `<strong>${escapeHtml(s.name)}</strong>
           <div class="small">${escapeHtml(s.root || '')}</div>
           <div class="tagrow">
             <span class="tag ${s.enabled ? 'good':''}">${escapeHtml(enabled)}</span>
             <span class="tag ${s.accessible ? 'good':'bad'}">${escapeHtml(reach)}</span>
             <span class="tag">${escapeHtml(s.type || 'local')}</span>
           </div>`;
        root.appendChild(card);
      }
    }

    function renderProjects(){
      const root = el('projects');
      root.innerHTML = '';
      if (!state.projects.length){
        root.innerHTML = `<div style="padding:12px;color:var(--muted);font-size:12px;">No projects yet ‚Äî create via <code>/api/projects</code>.</div>`;
        return;
      }
      for (const p of state.projects){
        const chip = document.createElement('div');
        chip.className = 'chip';
        if (state.activeProject && state.activeProject.name === p.name) chip.classList.add('active');
        chip.title = p.instructions || 'Browse this project';
        chip.innerHTML = `<span class="dot" aria-hidden="true"></span><span class="name">${escapeHtml(p.name)}</span>`;
        chip.addEventListener('click', () => selectProject(p));
        chip.addEventListener('dragover', (event) => {
          event.preventDefault();
          event.dataTransfer.dropEffect = 'move';
        });
        chip.addEventListener('drop', async (event) => {
          event.preventDefault();
          const raw = event.dataTransfer.getData('application/x-media-sync');
          if (!raw) return;
          try{
            const data = JSON.parse(raw);
            const paths = Array.isArray(data.paths) ? data.paths : [];
            if (!paths.length) return;
            await moveMedia(paths, p);
          }catch{}
        });
        root.appendChild(chip);
      }
      el('projCount').textContent = `${state.projects.length} total`;
    }

    function renderMedia(){
      const items = filteredMedia();
      const allMode = !state.activeProject && state.mediaScope === 'all';
      const canSelect = !!state.activeProject;

      // GRID
      const g = el('mediaGrid');
      g.innerHTML = '';
      // LIST
      const l = el('mediaList');
      l.innerHTML = '';

      if (!state.activeProject && !allMode){
        const empty = `<div style="padding:16px;color:var(--muted);font-size:12px;">
          Select a project to view media.
        </div>`;
        g.innerHTML = empty;
        l.innerHTML = empty;
        return;
      }

      if (!items.length){
        const empty = `<div style="padding:16px;color:var(--muted);font-size:12px;">
          ${allMode
            ? 'No indexed files yet across all projects.'
            : 'No indexed files yet. Upload then run <code>/reindex</code>.'}
        </div>`;
        g.innerHTML = empty;
        l.innerHTML = empty;
        return;
      }

      for (const it of items){
        const kind = guessKind(it);
        const title = it.relative_path?.split('/').pop() || it.relative_path || 'unnamed';
        const proj = projectLabel(it);
        const sub = proj ? `${it.relative_path || ''} ‚Ä¢ ${proj}` : (it.relative_path || '');
        const size = formatBytes(it.size);

        // If your API can provide a lightweight thumbnail URL (recommended), use it:
        // - it.thumb_url (image/jpg) for videos/images
        // Otherwise we can still show the actual stream_url for images (not always great for big video files).
        const thumbKey = thumbCacheKey(it);
        const cachedThumb = thumbKey ? thumbCache.get(thumbKey) : null;
        const fallbackThumb = buildThumbFallback(kind);
        const thumbUrl = cachedThumb || it.thumb_url || it.thumbnail_url || (kind === 'image' ? it.stream_url : null);
        const safeThumbUrl = thumbUrl || fallbackThumb;

        // ---- grid card
        const card = document.createElement('div');
        card.className = 'asset';
        if (canSelect){
          card.setAttribute('draggable', 'true');
          card.addEventListener('dragstart', (event) => attachDragData(event, it));
        }
        if (state.selected.has(it.relative_path)) card.classList.add('selected', 'is-selected');
        card.dataset.streamUrl = it.stream_url || it.streamUrl || '';
        card.dataset.relative = it.relative_path || '';
        card.dataset.project = it.project_name || it.project || state.activeProject?.name || '';
        card.dataset.source = it.project_source || it.source || state.activeProject?.source || '';

        card.innerHTML = `
          <div class="thumb" ${(!thumbUrl && kind === 'video') ? `data-rel="${escapeHtml(it.relative_path)}" data-url="${escapeHtml(it.stream_url || '')}" data-duration="${escapeHtml(it.duration || '')}" data-kind="video" data-thumb-key="${escapeHtml(thumbKey)}" data-state="idle" data-attempts="0"` : ''}>
            <img src="${escapeHtml(safeThumbUrl)}" alt="${escapeHtml(title)}" loading="lazy"
              onerror="this.onerror=null;this.src='${escapeHtml(fallbackThumb)}';" />
            <div class="badges">
              <span class="badge ${kindBadgeClass(kind)}">${escapeHtml(kind)}</span>
              <span class="badge">${escapeHtml(size)}</span>
            </div>
            <div class="selector" title="Select">
              <input type="checkbox" ${state.selected.has(it.relative_path) ? 'checked':''} aria-label="Select media" ${canSelect ? '' : 'disabled'} />
            </div>
          </div>
          <div class="body">
            <div class="title">${escapeHtml(title)}</div>
            <div class="sub">${escapeHtml(sub)}</div>
          </div>
        `;

        // checkbox toggles selection without opening drawer
        card.querySelector('input[type="checkbox"]').addEventListener('click', (ev) => {
          ev.stopPropagation();
          toggleSelected(it.relative_path);
        });

        // click card opens inspector
        card.addEventListener('click', () => openDrawer(it));
        g.appendChild(card);

      if (!thumbUrl && kind === 'video'){
          const t = card.querySelector('.thumb');
          primeThumbFromCache(t).then((found) => {
            if (!found) ensureThumbObserver().observe(t);
          });
        }

        // ---- list row
        const row = document.createElement('div');
        row.className = 'row';
        if (canSelect){
          row.setAttribute('draggable', 'true');
          row.addEventListener('dragstart', (event) => attachDragData(event, it));
        }
        if (state.selected.has(it.relative_path)) row.classList.add('selected', 'is-selected');
        row.dataset.streamUrl = it.stream_url || it.streamUrl || '';
        row.dataset.relative = it.relative_path || '';
        row.dataset.project = it.project_name || it.project || state.activeProject?.name || '';
        row.dataset.source = it.project_source || it.source || state.activeProject?.source || '';
        row.innerHTML = `
          <div class="mini" ${(!thumbUrl && kind === 'video') ? `data-rel="${escapeHtml(it.relative_path)}" data-url="${escapeHtml(it.stream_url || '')}" data-duration="${escapeHtml(it.duration || '')}" data-kind="video" data-thumb-key="${escapeHtml(thumbKey)}" data-state="idle" data-attempts="0"` : ''}>
            <img src="${escapeHtml(safeThumbUrl)}" alt="${escapeHtml(title)}" loading="lazy"
              onerror="this.onerror=null;this.src='${escapeHtml(fallbackThumb)}';" />
          </div>
          <div class="info">
            <div class="t">${escapeHtml(title)}</div>
            <div class="s">${escapeHtml(sub)} ‚Ä¢ ${escapeHtml(size)} ‚Ä¢ ${escapeHtml(kind)}</div>
          </div>
          <div class="actions">
            <input type="checkbox" ${state.selected.has(it.relative_path) ? 'checked':''} title="Select" ${canSelect ? '' : 'disabled'} />
            <button class="iconbtn" type="button">Preview</button>
          </div>
        `;
        row.querySelector('input[type="checkbox"]').addEventListener('change', () => toggleSelected(it.relative_path));
        row.querySelector('button').addEventListener('click', () => openDrawer(it));
        if (!thumbUrl && kind === 'video'){
          const t2 = row.querySelector('.mini');
          primeThumbFromCache(t2).then((found) => {
            if (!found) ensureThumbObserver().observe(t2);
          });
        }
        l.appendChild(row);
      }
      scheduleThumbSweep();
    }

    // -------------------------
    // Project selection + upload
    // -------------------------
    async function selectProject(p){
      state.activeProject = p;
      state.mediaScope = 'project';
      state.selected.clear();
      state.focused = null;

      // prefill resolve name
      el('resolveProjectMode').value = 'current';
      el('resolveProjectName').value = p.name || '';
      el('resolveNewName').value = '';

      el('uploadCaption').textContent = `Upload to ${p.name}${p.source ? ` (${p.source})` : ''}`;
      el('uploadBtn').disabled = false;

      renderProjects();
      updateTopCounts();
      renderMoveTargets();
      updateSelectionUI();
      toast('good', 'Project', `Selected ${p.name}`);
      await loadMedia();
    }

    async function uploadActive(){
      const p = state.activeProject;
      if (!p){ toast('warn','Upload','Select a project first'); return; }
      const f = el('uploadFile').files?.[0];
      if (!f){ toast('warn','Upload','Pick a file first'); return; }
      await uploadFiles([f]);
    }

    async function uploadFiles(files){
      const p = state.activeProject;
      if (!p){ toast('warn','Upload','Select a project first'); return; }
      if (!files.length){ return; }

      el('uploadBtn').disabled = true;
      el('uploadStatus').textContent = 'Uploading‚Ä¶';

      try{
        for (const f of files){
          const form = new FormData();
          form.append('file', f);
          const url = p.upload_url || `${API}/api/projects/${encodeURIComponent(p.name)}/upload${mediaQuery()}`;
          const r = await fetch(url, { method:'POST', body: form });
          const payload = await r.json().catch(() => ({}));
          if (!r.ok) throw new Error(payload.detail || payload.message || 'Upload failed');
        }
        const msg = files.length > 1 ? 'Uploads stored.' : 'Upload stored.';
        el('uploadStatus').textContent = msg;
        toast('good', 'Upload', msg);
        await loadMedia();
      }catch(e){
        el('uploadStatus').textContent = `Upload failed: ${e.message}`;
        toast('bad','Upload', e.message);
      }finally{
        el('uploadBtn').disabled = false;
      }
    }

    // -------------------------
    // Selection + Resolve
    // -------------------------
    function toggleSelected(relPath){
      if (!relPath) return;
      if (!state.activeProject) return;
      if (state.selected.has(relPath)) state.selected.delete(relPath);
      else state.selected.add(relPath);

      // update selected CSS quickly without full re-render
      // simplest: re-render; media lists are small enough on LAN.
      renderMedia();
      updateSelectionUI();
    }

    function clearSelection(){
      state.selected.clear();
      renderMedia();
      updateSelectionUI();
    }

    async function deletePaths(paths){
      const p = state.activeProject;
      if (!p){ toast('warn','Delete','Select a project first'); return; }
      if (!paths.length){ toast('warn','Delete','Select one or more clips'); return; }
      try{
        const r = await fetch(`${API}/api/projects/${encodeURIComponent(p.name)}/media/delete${mediaQuery()}`, {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify({ relative_paths: paths }),
        });
        const payload = await r.json().catch(() => ({}));
        if (!r.ok) throw new Error(payload.detail || payload.message || 'Delete failed');
        toast('good','Delete','Media removed from disk and index');
        for (const path of paths){ state.selected.delete(path); }
        if (state.focused && paths.includes(state.focused.relative_path)){
          state.focused = null;
          setInspectorOpen(false);
        }
        await loadMedia();
        updateSelectionUI();
      }catch(e){
        toast('bad','Delete', e.message);
      }
    }

    async function moveMedia(paths, targetProject){
      const p = state.activeProject;
      if (!p){ toast('warn','Move','Select a project first'); return; }
      if (!paths.length){ toast('warn','Move','Select one or more clips'); return; }
      try{
        const r = await fetch(`${API}/api/projects/${encodeURIComponent(p.name)}/media/move${mediaQuery()}`, {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify({
            relative_paths: paths,
            target_project: targetProject.name,
            target_source: targetProject.source || null,
          }),
        });
        const payload = await r.json().catch(() => ({}));
        if (!r.ok) throw new Error(payload.detail || payload.message || 'Move failed');
        toast('good','Move', `Moved ${paths.length} item(s) to ${targetProject.name}`);
        for (const path of paths){ state.selected.delete(path); }
        if (state.focused && paths.includes(state.focused.relative_path)){
          state.focused = null;
          setInspectorOpen(false);
        }
        await loadMedia();
        await loadProjects();
        updateSelectionUI();
      }catch(e){
        toast('bad','Move', e.message);
      }
    }

    async function sendToResolve(){
      const p = state.activeProject;
      if (!p){ toast('warn','Resolve','Select a project first'); return; }
      if (!state.selected.size){ toast('warn','Resolve','Select one or more clips'); return; }

      const projectMode = el('resolveProjectMode').value;
      let projectValue = p.name;

      if (projectMode === '__new__') projectValue = '__new__';
      else if (projectMode === '__select__') projectValue = '__select__';
      else {
        const v = (el('resolveProjectName').value || '').trim();
        if (v) projectValue = v;
      }

      const body = {
        project: projectValue,
        new_project_name: projectMode === '__new__'
          ? ((el('resolveNewName').value || '').trim() || null)
          : null,
        media_rel_paths: Array.from(state.selected),
        mode: el('resolveMode').value || 'import',
      };

      try{
        const r = await fetch(`${API}/api/resolve/open${mediaQuery()}`, {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify(body),
        });
        const payload = await r.json().catch(() => ({}));
        if (!r.ok) throw new Error(payload.detail || payload.message || 'Resolve request failed');
        toast('good','Resolve', `Sent. Job: ${payload.job_id || 'ok'}`);
      }catch(e){
        toast('bad','Resolve', e.message);
      }
    }

    // -------------------------
    // Drawer / inspector
    // -------------------------
    function openDrawer(item){
      state.focused = item;
      if (state.activeProject && item?.relative_path){
        state.selected.add(item.relative_path);
      }

      const kind = guessKind(item);
      const title = item.relative_path?.split('/').pop() || item.relative_path || 'unnamed';
      el('drawerTitle').textContent = title;
      el('drawerSub').textContent = item.relative_path || '';

      // preview
      const preview = el('drawerPreview');
      preview.innerHTML = '';
      if (kind === 'video'){
        const v = document.createElement('video');
        v.controls = true;
        v.src = item.stream_url || '';
        v.preload = 'metadata';
        preview.appendChild(v);
      }else if (kind === 'image'){
        const img = document.createElement('img');
        img.src = item.stream_url || item.thumb_url || item.thumbnail_url || '';
        img.alt = title;
        preview.appendChild(img);
      }else if (kind === 'audio'){
        const a = document.createElement('audio');
        a.controls = true;
        a.src = item.stream_url || '';
        preview.appendChild(a);
      }else{
        const box = document.createElement('div');
        box.style.padding = '14px';
        box.style.color = 'var(--muted)';
        box.style.fontSize = '12px';
        box.innerHTML = `No native preview for this type.<br><span class="kbd">${escapeHtml(kind)}</span>`;
        preview.appendChild(box);
      }

      // metadata table (show what you have; hides gracefully if missing)
      const kv = el('drawerKV');
      const activeProjectName = state.activeProject?.name || item.project_name || '';
      const activeSource = state.activeProject?.source || item.project_source || '';
      const rows = [
        ['Kind', kind],
        ['Size', formatBytes(item.size)],
        ['Stream', item.stream_url || '(none)'],
        ['Source', activeSource || '(primary)'],
        ['Project', activeProjectName || '(none)'],
        ['Relative', item.relative_path || '(none)'],
        // Optional fields if your API provides them:
        ['MIME', item.mime || item.content_type || ''],
        ['Hash', item.sha256 || item.hash || ''],
        ['Created', item.created_at || item.createdAt || ''],
        ['Modified', item.updated_at || item.updatedAt || ''],
        ['Duration', item.duration ? `${item.duration}s` : ''],
        ['Resolution', (item.width && item.height) ? `${item.width}√ó${item.height}` : ''],
      ].filter(([_, v]) => String(v || '').trim().length > 0);

      kv.innerHTML = rows.map(([k,v]) => `
        <div class="k">${escapeHtml(k)}</div>
        <div class="v">${escapeHtml(v)}</div>
      `).join('');

      // actions
      el('drawerPlay').onclick = () => {
        const media = preview.querySelector('video, audio');
        if (media) media.play?.();
      };

      el('drawerCopy').onclick = async () => {
        const u = toAbsoluteUrl(item.stream_url);
        const ok = await copyTextWithFallback(u);
        if (ok){
          toast('good','Copied', 'Stream URL copied to clipboard');
        }else{
          toast('warn','Clipboard', 'Copy failed ‚Äî please copy manually.');
        }
      };

      el('drawerTagToggle').onclick = () => {
        const panel = el('drawerTagPanel');
        panel?.classList.toggle('open');
        if (panel?.classList.contains('open')){
          el('drawerTagInput')?.focus();
        }
      };

      el('drawerSendOBS').onclick = async () => {
        const assetUrl = toAbsoluteUrl(item.stream_url);
        if (!assetUrl){
          toast('warn','OBS', 'No stream URL available for this asset.');
          return;
        }

        const btn = el('drawerSendOBS');
        const prevText = btn.textContent;
        btn.textContent = 'üì° Sending‚Ä¶';
        btn.disabled = true;

        try{
          await obsReplaceAssetMediaUrl({
            obsHost: '192.168.0.187',
            sceneName: 'ASSET_MEDIA',
            inputName: 'ASSET_MEDIA',
            fit: 'cover',
            muted: false,
            assetUrl,
          });
          toast('good','OBS', 'Browser source updated.');
          btn.textContent = '‚úÖ Sent';
          setTimeout(() => {
            btn.textContent = prevText;
          }, 900);
        }catch(e){
          console.error('[OBS] push failed:', e);
          toast('bad','OBS', e.message || 'OBS push failed.');
          btn.textContent = prevText;
        }finally{
          btn.disabled = false;
        }
      };

      el('drawerTagAdd').onclick = () => {
        const tags = parseTagInput(el('drawerTagInput').value);
        applyTagsToPaths([item.relative_path], tags, []);
        el('drawerTagInput').value = '';
        updateTagButtons();
      };
      el('drawerTagRemove').onclick = () => {
        const tags = parseTagInput(el('drawerTagInput').value);
        applyTagsToPaths([item.relative_path], [], tags);
        el('drawerTagInput').value = '';
        updateTagButtons();
      };

      // open
      el('drawerTagPanel').classList.toggle('is-hidden', !item);
      loadDrawerTags(item);
      setInspectorOpen(true);
      updateSelectionUI();
    }

    function closeDrawer(){
      setInspectorOpen(false);
    }

    // -------------------------
    // Events / bindings
    // -------------------------
    el('refreshBtn').addEventListener('click', async () => {
      await loadSources();
      await loadProjects();
      if (state.activeProject){
        await loadMedia();
      }else{
        await loadAllMedia();
      }
      toast('good','Refresh','Reloaded projects + media');
    });

    el('brandTitle').addEventListener('click', (event) => {
      event.stopPropagation();
      setSidebarOpen(!ui.sidebarOpen);
    });
    el('sidebarBackdrop').addEventListener('click', () => setSidebarOpen(false));
    el('drawerBackdrop').addEventListener('click', closeDrawer);

    const actionsToggle = el('actionsToggle');
    const actionsPanel = el('actionsPanel');
    const toggleActions = (open) => {
      actionsPanel.classList.toggle('open', open);
      actionsToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
    };
    actionsToggle.addEventListener('click', (event) => {
      event.stopPropagation();
      const isOpen = actionsPanel.classList.contains('open');
      toggleActions(!isOpen);
    });
    document.addEventListener('click', (event) => {
      if (!actionsPanel.classList.contains('open')) return;
      if (actionsPanel.contains(event.target) || actionsToggle.contains(event.target)) return;
      toggleActions(false);
    });

    el('viewGrid').addEventListener('click', () => setView('grid'));
    el('viewList').addEventListener('click', () => setView('list'));

    el('q').addEventListener('input', (e) => {
      state.q = e.target.value || '';
      renderMedia();
      updateTopCounts();
    });

    el('batchTagInput').addEventListener('input', updateTagButtons);
    el('drawerTagInput').addEventListener('input', updateTagButtons);

    el('batchTagAdd').addEventListener('click', () => {
      const tags = parseTagInput(el('batchTagInput').value);
      applyTagsToPaths(Array.from(state.selected), tags, []);
      el('batchTagInput').value = '';
      updateTagButtons();
    });
    el('batchTagRemove').addEventListener('click', () => {
      const tags = parseTagInput(el('batchTagInput').value);
      applyTagsToPaths(Array.from(state.selected), [], tags);
      el('batchTagInput').value = '';
      updateTagButtons();
    });

    // Upload
    el('uploadBtn').addEventListener('click', uploadActive);
    el('pickUploadBtn').addEventListener('click', () => el('uploadFile').click());

    const contentArea = document.querySelector('.content');
    if (contentArea){
      contentArea.addEventListener('dragover', (event) => {
        if (event.dataTransfer?.types?.includes('Files')){
          event.preventDefault();
          event.dataTransfer.dropEffect = 'copy';
          setDragActive(true);
        }
      });
      contentArea.addEventListener('dragleave', () => setDragActive(false));
      contentArea.addEventListener('drop', (event) => {
        if (!event.dataTransfer?.files?.length) return;
        event.preventDefault();
        setDragActive(false);
        uploadFiles(Array.from(event.dataTransfer.files));
      });
    }

    // Resolve
    el('sendResolveBtn').addEventListener('click', sendToResolve);

    // Clear selection
    el('clearSelBtn').addEventListener('click', clearSelection);
    el('deleteSelBtn').addEventListener('click', () => deletePaths(Array.from(state.selected)));

    // Selection bar actions
    el('selTagToggle').addEventListener('click', () => toggleSelectPanel('selTagPanel'));
    el('selMoveToggle').addEventListener('click', () => {
      renderMoveTargets();
      toggleSelectPanel('selMovePanel');
    });
    el('selCopyUrls').addEventListener('click', copySelectedUrls);
    el('btnProgramMonitor').addEventListener('click', sendSelectedToProgramMonitor);
    el('selTagInput').addEventListener('input', updateTagButtons);
    el('selTagAdd').addEventListener('click', () => {
      const tags = parseTagInput(el('selTagInput').value);
      applyTagsToPaths(Array.from(state.selected), tags, []);
      el('selTagInput').value = '';
      updateTagButtons();
    });
    el('selTagRemove').addEventListener('click', () => {
      const tags = parseTagInput(el('selTagInput').value);
      applyTagsToPaths(Array.from(state.selected), [], tags);
      el('selTagInput').value = '';
      updateTagButtons();
    });
    el('selMoveSubmit').addEventListener('click', async () => {
      const select = el('selMoveTarget');
      const value = select?.value || '';
      if (!value){
        toast('warn','Move','Select a target project');
        return;
      }
      let target;
      try{
        target = JSON.parse(value);
      }catch{
        toast('warn','Move','Select a target project');
        return;
      }
      await moveMedia(Array.from(state.selected), target);
      setSelectPanel('selMovePanel', false);
    });

    // Drawer close
    el('drawerClose').addEventListener('click', closeDrawer);
    el('drawerDelete').addEventListener('click', () => {
      if (!state.focused) return;
      deletePaths([state.focused.relative_path]);
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape'){
        if (ui.inspectorOpen){
          closeDrawer();
          e.preventDefault();
          return;
        }
        if (ui.sidebarOpen){
          setSidebarOpen(false);
          e.preventDefault();
          return;
        }
      }
      // cheap "cmd+k" focus
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'k'){
        e.preventDefault();
        el('q').focus();
      }
    });

    // Resolve hint updates
    function syncResolveHint(){
      const c = state.selected.size;
      el('resolveHint').textContent = c
        ? `${c} item(s) queued.`
        : 'Select clips to enable.';
    }
    const _origUpdateSelectionUI = updateSelectionUI;
    updateSelectionUI = function(){
      _origUpdateSelectionUI();
      syncResolveHint();
    };

    // Boot
    document.addEventListener('DOMContentLoaded', async () => {
      syncSidebarMode();
      window.matchMedia('(max-width: 860px)').addEventListener('change', () => {
        syncSidebarMode();
      });
      const scrollRoot = el('mediaScroll');
      if (scrollRoot){
        scrollRoot.addEventListener('scroll', () => scheduleThumbSweep(), { passive: true });
      }

      toast('good','Boot','Loading sources + projects‚Ä¶');
      await loadSources();
      await loadProjects();
      if (!state.activeProject){
        await loadAllMedia();
      }
      setView('grid');
      updateTopCounts();
      updateSelectionUI();
    });
  </script>
</body>
</html>
